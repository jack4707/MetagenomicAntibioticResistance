{
  "sbg:revision": 1,
  "steps": [
    {
      "run": {
        "temporaryFailCodes": [],
        "baseCommand": [
          "tar",
          "-xvf",
          {
            "script": "$job.inputs.genome.path",
            "class": "Expression",
            "engine": "#cwl-js-engine"
          },
          "&&",
          "/opt/STAR-2.5.1b/bin/Linux_x86_64_static/STAR",
          "--runThreadN",
          {
            "script": "{\n  return $job.allocatedResources.cpu\n}",
            "class": "Expression",
            "engine": "#cwl-js-engine"
          }
        ],
        "sbg:revision": 0,
        "successCodes": [],
        "y": 196.68230040930223,
        "sbg:job": {
          "inputs": {
            "unmappedOutputName": "Uncontamimated",
            "chimJunctionOverhangMin": 0,
            "alignEndsType": "Local",
            "scoreDelOpen": 0,
            "seedSearchStartLmax": 0,
            "rg_platform_unit_id": "rg_platform_unit",
            "outSJfilterIntronMaxVsReadN": [
              0
            ],
            "sjdbScore": null,
            "chimScoreJunctionNonGTAG": 0,
            "alignSoftClipAtReferenceEnds": "Yes",
            "alignSplicedMateMapLminOverLmate": 0,
            "outSAMheaderHD": "outSAMheaderHD",
            "chimSegmentMin": 15,
            "seedSearchStartLmaxOverLread": 0,
            "outSJfilterOverhangMin": [
              30,
              12,
              12,
              12
            ],
            "outSJfilterCountTotalMin": [
              3,
              1,
              1,
              1
            ],
            "outSAMmode": "Full",
            "winFlankNbins": 0,
            "rg_sample_id": "rg_sample",
            "outSAMunmapped": "None",
            "chimScoreSeparation": 0,
            "scoreStitchSJshift": 0,
            "winAnchorDistNbins": 0,
            "twopassMode": "Basic",
            "outSAMfilter": "KeepOnlyAddedReference",
            "outFilterScoreMinOverLread": 0,
            "scoreGapGCAG": 0,
            "alignSJDBoverhangMin": 0,
            "outSAMprimaryFlag": "OneBestScore",
            "reads": [
              {
                "metadata": {
                  "paired_end": "1"
                },
                "class": "File",
                "path": "/test-data/test_sample_1.fastq",
                "secondaryFiles": [],
                "size": 0
              }
            ],
            "sortUnmappedReads": true,
            "clip3pAdapterMMp": [
              0
            ],
            "limitOutSJcollapsed": 0,
            "outFilterType": "Normal",
            "winAnchorMultimapNmax": 0,
            "seedSearchLmax": 0,
            "readMapNumber": 0,
            "alignIntronMax": 0,
            "limitOutSJoneRead": 0,
            "outFilterMismatchNoverReadLmax": 0,
            "chimFilter": "banGenomicN",
            "scoreGenomicLengthLog2scale": 0,
            "seedMultimapNmax": 0,
            "scoreInsBase": 0,
            "sjdbGTFchrPrefix": "chrPrefix",
            "sjdbOverhang": null,
            "outFilterMultimapScoreRange": 0,
            "outSJfilterCountUniqueMin": [
              3,
              1,
              1,
              1
            ],
            "chimOutType": "Within",
            "alignWindowsPerReadNmax": 0,
            "sjdbInsertSave": "Basic",
            "genome": {
              "class": "File",
              "path": "genome.ext",
              "secondaryFiles": [],
              "size": 0
            },
            "alignSplicedMateMapLmin": 0,
            "outFilterMultimapNmax": 0,
            "outReadsUnmapped": "Fastx",
            "outSAMstrandField": "None",
            "scoreGapNoncan": 0,
            "quantTranscriptomeBan": "IndelSoftclipSingleend",
            "alignSJstitchMismatchNmax": "alignSJstitchMismatchNmax-string-value",
            "scoreGapATAC": 0,
            "outSAMmultNmax": 0,
            "quantMode": "TranscriptomeSAM",
            "outSJfilterDistToOtherSJmin": [
              0
            ],
            "winBinNbits": 0,
            "sjdbGTFfile": [
              {
                "path": "/demo/test-data/chr20.gtf"
              }
            ],
            "alignTranscriptsPerReadNmax": 0,
            "outFilterMatchNminOverLread": 0,
            "limitBAMsortRAM": 0,
            "outSAMflagOR": 0,
            "limitSjdbInsertNsj": 0,
            "scoreInsOpen": 0,
            "outSJfilterReads": "All",
            "seedPerReadNmax": 0,
            "sjdbGTFtagExonParentGene": "",
            "clip5pNbases": [
              0
            ],
            "outSAMheaderPG": "outSAMheaderPG",
            "twopass1readsN": -2,
            "outMultimapperOrder": "Random",
            "outSAMtype": "SAM",
            "outFilterMismatchNmax": 0,
            "outSAMreadID": "Standard",
            "outSAMflagAND": 0,
            "outSAMattributes": "Standard",
            "scoreDelBase": 0,
            "clip3pNbases": [
              0,
              3
            ],
            "outFilterScoreMin": 0,
            "chimSegmentReadGapMax": 8,
            "scoreGap": 0,
            "outFilterMatchNmin": 0,
            "outFilterIntronMotifs": "None",
            "rg_seq_center": "",
            "rg_library_id": "",
            "alignIntronMin": 0,
            "outSortingType": "SortedByCoordinate",
            "outSAMmapqUnique": 0,
            "GENOME_DIR_NAME": "",
            "sjdbGTFfeatureExon": "",
            "clip3pAfterAdapterNbases": [
              0
            ],
            "outFilterMismatchNoverLmax": 0,
            "readMatesLengthsIn": "NotEqual",
            "seedPerWindowNmax": 0,
            "no_read_groups": false,
            "rg_platform": "Ion Torrent PGM",
            "clip3pAdapterSeq": [
              "clip3pAdapterSeq"
            ],
            "alignTranscriptsPerWindowNmax": 0,
            "rg_mfl": "rg_mfl",
            "chimScoreDropMax": 0,
            "chimScoreMin": 0,
            "alignSJoverhangMin": 0,
            "outSAMorder": "Paired",
            "seedNoneLociPerWindow": 0,
            "outQSconversionAdd": 0,
            "alignMatesGapMax": 0,
            "outSAMattrIHstart": 6,
            "sjdbGTFtagExonParentTranscript": ""
          },
          "allocatedResources": {
            "mem": 60000,
            "cpu": 32
          }
        },
        "sbg:id": "krishnanus/initialtesting/star-2-5-1-b/0",
        "sbg:validationErrors": [],
        "sbg:toolkitVersion": "2.5.1b",
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:project": "krishnanus/initialtesting",
        "sbg:copyOf": "admin/sbg-public-data/star-2-5-1-b/41",
        "appUrl": "/u/krishnanus/initialtesting/apps/#krishnanus/initialtesting/star-2-5-1-b/0",
        "x": 719.3333605925246,
        "sbg:createdBy": "tsang",
        "description": "STAR is an ultrafast universal RNA-seq aligner. It has very high mapping speed, accurate alignment of contiguous and spliced reads, detection of polyA-tails, non-canonical splices and chimeric (fusion) junctions. It works with reads starting from lengths ~15 bases up to ~300 bases. In case of having longer reads, use of STAR Long is recommended.\n\n###Common issues###\n1. In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.\n2. Files in multi-FASTQ format are currently not supported, i.e. if you have single-end reads that span multiple FASTQ files, or paired-end reads that span more than 2 files, please use a tool like SBG Merge FASTQs before providing your files to the STAR aligner. \n3. If you are providing a GFF3 file and wish to use STAR results for further downstream analysis, a good idea would be to set the \"Exons' parents name\" (id: sjdbGTFtagExonParentTranscript) option to \"Parent\".\n4. Unmapped reads are, by default, unsorted. If you want to sort them by read ID, please specify the \"Sort unmapped reads\" option, though keep in mind that this can increase STAR run time.",
        "sbg:links": [
          {
            "id": "https://github.com/alexdobin/STAR",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/alexdobin/STAR/releases",
            "label": "Releases"
          },
          {
            "id": "https://github.com/alexdobin/STAR/blob/master/doc/STARmanual.pdf",
            "label": "Manual"
          },
          {
            "id": "https://groups.google.com/forum/#!forum/rna-star",
            "label": "Support"
          },
          {
            "id": "http://www.ncbi.nlm.nih.gov/pubmed/23104886",
            "label": "Publication"
          }
        ],
        "sbg:modifiedBy": "tsang",
        "sbg:projectName": "InitialTesting",
        "sbg:sbgMaintained": false,
        "sbg:license": "GNU General Public License v3.0 only",
        "label": "STAR",
        "sbg:cmdPreview": "tar -xvf genome.ext && /opt/STAR-2.5.1b/bin/Linux_x86_64_static/STAR --runThreadN 32    --sjdbGTFfile /demo/test-data/chr20.gtf  --sjdbGTFchrPrefix chrPrefix --sjdbInsertSave Basic  --twopass1readsN -2  --chimOutType WithinSAM  --outSAMattrRGline ID:1 PI:rg_mfl PL:Ion_Torrent_PGM PU:rg_platform_unit SM:rg_sample  --quantMode TranscriptomeSAM --outFileNamePrefix ./test_sample_1.fastq.  --readFilesIn /test-data/test_sample_1.fastq  && tar -vcf test_sample_1.fastq._STARgenome.tar ./test_sample_1.fastq._STARgenome   && cat test_sample_1.fastq.Unmapped.out.mate1 | sed 's/\\t.*//' | paste - - - - | sort -k1,1 -S 10G | tr '\\t' '\\n' > test_sample_1.fastq.Uncontamimated.mate1.fastq && rm test_sample_1.fastq.Unmapped.out.mate1",
        "stdout": "",
        "sbg:latestRevision": 0,
        "hints": [
          {
            "dockerPull": "images.sbgenomics.com/ana_d/star-fusion:2.5.1b",
            "class": "DockerRequirement",
            "dockerImageId": ""
          },
          {
            "class": "sbg:MemRequirement",
            "value": 60000
          },
          {
            "class": "sbg:CPURequirement",
            "value": 32
          }
        ],
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "class": "ExpressionEngineRequirement"
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "sbg:createdOn": 1499349815,
        "inputs": [
          {
            "sbg:toolDefaultValue": "4",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--winFlankNbins"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#winFlankNbins",
            "label": "Flanking regions size",
            "description": "=log2(winFlank), where win Flank is the size of the left and right flanking regions for each window (int>0).",
            "sbg:category": "Windows, Anchors, Binning"
          },
          {
            "sbg:toolDefaultValue": "16",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--winBinNbits"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#winBinNbits",
            "label": "Bin size",
            "description": "=log2(winBin), where winBin is the size of the bin for the windows/clustering, each window will occupy an integer number of bins (int>0).",
            "sbg:category": "Windows, Anchors, Binning"
          },
          {
            "sbg:toolDefaultValue": "50",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--winAnchorMultimapNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#winAnchorMultimapNmax",
            "label": "Max loci anchors",
            "description": "Max number of loci anchors are allowed to map to (int>0).",
            "sbg:category": "Windows, Anchors, Binning"
          },
          {
            "sbg:toolDefaultValue": "9",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--winAnchorDistNbins"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#winAnchorDistNbins",
            "label": "Max bins between anchors",
            "description": "Max number of bins between two anchors that allows aggregation of anchors into one window (int>0).",
            "sbg:category": "Windows, Anchors, Binning"
          },
          {
            "sbg:toolDefaultValue": "\"Unmapped.out\"",
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#unmappedOutputName",
            "sbg:category": "Output",
            "label": "Unmapped output file names",
            "description": "Names of the unmapped output files.",
            "sbg:includeInPorts": false
          },
          {
            "sbg:toolDefaultValue": "None",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--twopassMode"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "Basic"
                ],
                "name": "twopassMode",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#twopassMode",
            "label": "Two-pass mode",
            "description": "2-pass mapping mode. None: 1-pass mapping; Basic: basic 2-pass mapping, with all 1st pass junctions inserted into the genome indices on the fly.",
            "sbg:category": "2-pass mapping"
          },
          {
            "sbg:toolDefaultValue": "-1",
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#twopass1readsN",
            "label": "Reads to process in 1st step",
            "description": "Number of reads to process for the 1st step. 0: 1-step only, no 2nd pass; use very large number (or default -1) to map all reads in the first step (int>0).",
            "sbg:category": "2-pass mapping"
          },
          {
            "sbg:toolDefaultValue": "Off",
            "type": [
              "null",
              "boolean"
            ],
            "required": false,
            "id": "#sortUnmappedReads",
            "label": "Sort unmapped reads",
            "description": "Unmapped reads are, by default, unsorted. If you want to sort them by read ID, please specify this option, though keep in mind that this can increase STAR run time.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "2",
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#sjdbScore",
            "label": "Extra alignment score",
            "description": "Extra alignment score for alignments that cross database junctions.",
            "sbg:category": "Splice junctions database"
          },
          {
            "sbg:toolDefaultValue": "100",
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#sjdbOverhang",
            "label": "\"Overhang\" length",
            "description": "Length of the donor/acceptor sequence on each side of the junctions, ideally = (mate_length - 1) (int >= 0), if int = 0, splice junction database is not used.",
            "sbg:category": "Splice junctions database"
          },
          {
            "sbg:toolDefaultValue": "None",
            "type": [
              "null",
              {
                "symbols": [
                  "Basic",
                  "All",
                  "None"
                ],
                "name": "sjdbInsertSave",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#sjdbInsertSave",
            "label": "Save junction files",
            "description": "Which files to save when sjdb junctions are inserted on the fly at the mapping step. None: not saving files at all; Basic: only small junction/transcript files; All: all files including big Genome, SA and SAindex. These files are output as archive.",
            "sbg:category": "Splice junctions database"
          },
          {
            "sbg:toolDefaultValue": "transcript_id",
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#sjdbGTFtagExonParentTranscript",
            "label": "Exons' parents name",
            "description": "Tag name to be used as exons transcript-parents.",
            "sbg:category": "Splice junctions database"
          },
          {
            "sbg:toolDefaultValue": "gene_id",
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#sjdbGTFtagExonParentGene",
            "label": "Gene name",
            "description": "Tag name to be used as exons gene-parents.",
            "sbg:category": "Splice junctions database"
          },
          {
            "sbg:fileTypes": "GTF, GFF, GFF2, GFF3, TXT",
            "type": [
              "null",
              {
                "name": "sjdbGTFfile",
                "items": "File",
                "type": "array"
              }
            ],
            "required": false,
            "id": "#sjdbGTFfile",
            "label": "Splice junction file",
            "description": "Gene model annotations and/or known transcripts. No need to include this input, except in case of using \"on the fly\" annotations. If you are providing a GFF3 file and wish to use STAR results for further downstream analysis, a good idea would be to set the \"Exons' parents name\" (id: sjdbGTFtagExonParentTranscript) option to \"Parent\".",
            "sbg:category": "Basic"
          },
          {
            "sbg:toolDefaultValue": "exon",
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#sjdbGTFfeatureExon",
            "label": "Set exons feature",
            "description": "Feature type in GTF file to be used as exons for building transcripts.",
            "sbg:category": "Splice junctions database"
          },
          {
            "sbg:toolDefaultValue": "-",
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#sjdbGTFchrPrefix",
            "label": "Chromosome names",
            "description": "Prefix for chromosome names in a GTF file (e.g. 'chr' for using ENSMEBL annotations with UCSC geneomes).",
            "sbg:category": "Splice junctions database"
          },
          {
            "sbg:toolDefaultValue": "1.0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedSearchStartLmaxOverLread"
            },
            "type": [
              "null",
              "float"
            ],
            "required": false,
            "id": "#seedSearchStartLmaxOverLread",
            "label": "Search start point normalized",
            "description": "SeedSearchStartLmax normalized to read length (sum of mates' lengths for paired-end reads).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "50",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedSearchStartLmax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#seedSearchStartLmax",
            "label": "Search start point",
            "description": "Defines the search start point through the read - the read is split into pieces no longer than this value (int>0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedSearchLmax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#seedSearchLmax",
            "label": "Max seed length",
            "description": "Defines the maximum length of the seeds, if =0 max seed length is infinite (int>=0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "50",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedPerWindowNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#seedPerWindowNmax",
            "label": "Max seeds per window",
            "description": "Max number of seeds per window (int>=0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "1000",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedPerReadNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#seedPerReadNmax",
            "label": "Max seeds per read",
            "description": "Max number of seeds per read (int>=0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "10",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedNoneLociPerWindow"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#seedNoneLociPerWindow",
            "label": "Max one-seed loci per window",
            "description": "Max number of one seed loci per window (int>=0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "10000",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seedMultimapNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#seedMultimapNmax",
            "label": "Filter pieces for stitching",
            "description": "Only pieces that map fewer than this value are utilized in the stitching procedure (int>=0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreStitchSJshift"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#scoreStitchSJshift",
            "label": "Max score reduction",
            "description": "Maximum score reduction while searching for SJ boundaries in the stitching step.",
            "sbg:category": "Scoring"
          },
          {
            "sbg:toolDefaultValue": "-2",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreInsOpen"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#scoreInsOpen",
            "label": "Insertion Open Penalty",
            "description": "Insertion open penalty.",
            "sbg:category": "Scoring"
          },
          {
            "sbg:toolDefaultValue": "-2",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreInsBase"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#scoreInsBase",
            "label": "Insertion extension penalty",
            "description": "Insertion extension penalty per base (in addition to --scoreInsOpen).",
            "sbg:category": "Scoring"
          },
          {
            "sbg:toolDefaultValue": "-0.25",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreGenomicLengthLog2scale"
            },
            "type": [
              "null",
              "float"
            ],
            "required": false,
            "id": "#scoreGenomicLengthLog2scale",
            "label": "Log scaled score",
            "description": "Extra score logarithmically scaled with genomic length of the alignment: <int>*log2(genomicLength).",
            "sbg:category": "Scoring"
          },
          {
            "sbg:toolDefaultValue": "-8",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreGapNoncan"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#scoreGapNoncan",
            "label": "Non-canonical gap open",
            "description": "Non-canonical gap open penalty (in addition to --scoreGap).",
            "sbg:category": "Scoring"
          },
          {
            "sbg:toolDefaultValue": "-4",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreGapGCAG"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#scoreGapGCAG",
            "label": "GC/AG and CT/GC gap open",
            "description": "GC/AG and CT/GC gap open penalty (in addition to --scoreGap).",
            "sbg:category": "Scoring"
          },
          {
            "sbg:toolDefaultValue": "-8",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreGapATAC"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#scoreGapATAC",
            "label": "AT/AC and GT/AT gap open",
            "description": "AT/AC and GT/AT gap open penalty (in addition to --scoreGap).",
            "sbg:category": "Scoring"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreGap"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#scoreGap",
            "label": "Gap open penalty",
            "description": "Gap open penalty.",
            "sbg:category": "Scoring"
          },
          {
            "sbg:toolDefaultValue": "-2",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreDelOpen"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#scoreDelOpen",
            "label": "Deletion open penalty",
            "description": "Deletion open penalty.",
            "sbg:category": "Scoring"
          },
          {
            "sbg:toolDefaultValue": "-2",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--scoreDelBase"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#scoreDelBase",
            "label": "Deletion extension penalty",
            "description": "Deletion extension penalty per base (in addition to --scoreDelOpen).",
            "sbg:category": "Scoring"
          },
          {
            "sbg:toolDefaultValue": "Inferred from metadata",
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#rg_seq_center",
            "label": "Sequencing center",
            "description": "Specify the sequencing center for RG line.",
            "sbg:category": "Read group"
          },
          {
            "sbg:toolDefaultValue": "Inferred from metadata",
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#rg_sample_id",
            "label": "Sample ID",
            "description": "Specify the sample ID for RG line.",
            "sbg:category": "Read group"
          },
          {
            "sbg:toolDefaultValue": "Inferred from metadata",
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#rg_platform_unit_id",
            "label": "Platform unit ID",
            "description": "Specify the platform unit ID for RG line.",
            "sbg:category": "Read group"
          },
          {
            "sbg:toolDefaultValue": "Inferred from metadata",
            "type": [
              "null",
              {
                "symbols": [
                  "LS 454",
                  "Helicos",
                  "Illumina",
                  "ABI SOLiD",
                  "Ion Torrent PGM",
                  "PacBio"
                ],
                "name": "rg_platform",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#rg_platform",
            "label": "Platform",
            "description": "Specify the version of the technology that was used for sequencing or assaying.",
            "sbg:category": "Read group"
          },
          {
            "sbg:toolDefaultValue": "Inferred from metadata",
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#rg_mfl",
            "label": "Median fragment length",
            "description": "Specify the median fragment length for RG line.",
            "sbg:category": "Read group"
          },
          {
            "sbg:toolDefaultValue": "Inferred from metadata",
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#rg_library_id",
            "label": "Library ID",
            "description": "Specify the library ID for RG line.",
            "sbg:category": "Read group"
          },
          {
            "inputBinding": {
              "valueFrom": {
                "script": "{\n  var list = [].concat($job.inputs.reads)\n  var all_samples = []\n  \n  getUnique = function(arr){\n    var u = {}, a = [];\n    for(var i = 0, l = arr.length; i < l; ++i){\n      if(u.hasOwnProperty(arr[i])) {\n        continue;\n      }\n      a.push(arr[i]);\n      u[arr[i]] = 1;\n    }\n    return a;\n  }\n    \n  for (index = 0; index < list.length; ++index) {\n    if (list[index].metadata != null){\n      all_samples.push(list[index].metadata.sample_id)\n    }\n  }\n  samples = getUnique(all_samples)\n  \n  var samples_given = all_samples.length == list.length\n  \n  for (index = 0; index < list.length; ++index) {\n    if (list[index].metadata != null){\n      all_samples.push(list[index].metadata.sample_id)\n    }\n  }\n  samples = getUnique(all_samples)\n  var resp = []\n  \n  if (list.length == 1){\n    resp.push(list[0].path)\n    \n  }else if (list.length == 2){    \n    \n    left = \"\"\n    right = \"\"\n      \n    for (index = 0; index < list.length; ++index) {\n      \n      if (list[index].metadata != null){\n        if (list[index].metadata.paired_end == 1){\n          left = list[index].path\n        }else if (list[index].metadata.paired_end == 2){\n          right = list[index].path\n        }\n      }\n    }\n    \n    if (left != \"\" && right != \"\"){      \n      resp.push(left)\n      resp.push(right)\n    }\n  }\n  else if (list.length > 2){\n    left = []\n    right = []\n    if (samples_given){\n      for (sample_ind = 0; sample_ind < samples.length; ++sample_ind){\n        for (read_ind = 0; read_ind < list.length; ++read_ind){\n          if (list[read_ind].metadata != null){\n            if (list[read_ind].metadata.paired_end == 1 && list[read_ind].metadata.sample_id == samples[sample_ind]){\n              left.push(list[read_ind].path)\n            }else if (list[read_ind].metadata.paired_end == 2 && list[read_ind].metadata.sample_id == samples[sample_ind]){\n              right.push(list[read_ind].path)}\n          }\n        }\n      }\n    } else {\n        for (index = 0; index < list.length; ++index) {\n\n          if (list[index].metadata != null){\n            if (list[index].metadata.paired_end == 1){\n              left.push(list[index].path)\n            }else if (list[index].metadata.paired_end == 2){\n              right.push(list[index].path)\n            }\n          }\n        }\n    }\n\n\n    left_join = left.join()\n    right_join = right.join()\n    if (left != [] && right != []){      \n      resp.push(left_join)\n      resp.push(right_join)\n    }\n    }\n  \n  if(resp.length > 0){    \n    return \"--readFilesIn \".concat(resp.join(\" \"))\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": " ",
              "position": 10
            },
            "sbg:fileTypes": "FASTA, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "type": [
              {
                "name": "reads",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true,
            "id": "#reads",
            "label": "Read sequence",
            "description": "Read sequence.",
            "sbg:category": "Basic"
          },
          {
            "sbg:toolDefaultValue": "NotEqual",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--readMatesLengthsIn"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "NotEqual",
                  "Equal"
                ],
                "name": "readMatesLengthsIn",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#readMatesLengthsIn",
            "label": "Reads lengths",
            "description": "Equal/Not equal - lengths of names, sequences, qualities for both mates are the same/not the same. \"Not equal\" is safe in all situations.",
            "sbg:category": "Read parameters"
          },
          {
            "sbg:toolDefaultValue": "-1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--readMapNumber"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#readMapNumber",
            "label": "Reads to map",
            "description": "Number of reads to map from the beginning of the file.",
            "sbg:category": "Read parameters"
          },
          {
            "sbg:toolDefaultValue": "IndelSoftclipSingleend",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--quantTranscriptomeBan"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "IndelSoftclipSingleend",
                  "Singleend"
                ],
                "name": "quantTranscriptomeBan",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#quantTranscriptomeBan",
            "label": "Prohibit alignment type",
            "description": "Prohibit various alignment type. IndelSoftclipSingleend: prohibit indels, soft clipping and single-end alignments - compatible with RSEM; Singleend: prohibit single-end alignments.",
            "sbg:category": "Quantification of Annotations"
          },
          {
            "sbg:toolDefaultValue": "-",
            "type": [
              "null",
              {
                "symbols": [
                  "TranscriptomeSAM",
                  "GeneCounts",
                  "TranscriptomeSAM GeneCounts"
                ],
                "name": "quantMode",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#quantMode",
            "label": "Quantification mode",
            "description": "Types of quantification requested. 'TranscriptomeSAM' option outputs SAM/BAM alignments to transcriptome into a separate file. With 'GeneCounts' option, STAR will count number of reads per gene while mapping.",
            "sbg:category": "Quantification of Annotations"
          },
          {
            "sbg:toolDefaultValue": "Unsorted",
            "type": [
              "null",
              {
                "symbols": [
                  "Unsorted",
                  "SortedByCoordinate"
                ],
                "name": "outSortingType",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outSortingType",
            "label": "Output sorting type",
            "description": "Type of output sorting.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "All",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSJfilterReads"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "All",
                  "Unique"
                ],
                "name": "outSJfilterReads",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outSJfilterReads",
            "label": "Collapsed junctions reads",
            "description": "Which reads to consider for collapsed splice junctions output. All: all reads, unique- and multi-mappers; Unique: uniquely mapping reads only.",
            "sbg:category": "Output filtering: splice junctions"
          },
          {
            "sbg:toolDefaultValue": "30 12 12 12",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": " ",
              "prefix": "--outSJfilterOverhangMin"
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false,
            "id": "#outSJfilterOverhangMin",
            "label": "Min overhang SJ",
            "description": "Minimum overhang length for splice junctions on both sides for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Does not apply to annotated junctions.",
            "sbg:category": "Output filtering: splice junctions"
          },
          {
            "sbg:toolDefaultValue": "50000 100000 200000",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": " ",
              "prefix": "--outSJfilterIntronMaxVsReadN"
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false,
            "id": "#outSJfilterIntronMaxVsReadN",
            "label": "Max gap allowed",
            "description": "Maximum gap allowed for junctions supported by 1,2,3...N reads (int >= 0) i.e. by default junctions supported by 1 read can have gaps <=50000b, by 2 reads: <=100000b, by 3 reads: <=200000. By 4 or more reads: any gap <=alignIntronMax. Does not apply to annotated junctions.",
            "sbg:category": "Output filtering: splice junctions"
          },
          {
            "sbg:toolDefaultValue": "10 0 5 10",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": " ",
              "prefix": "--outSJfilterDistToOtherSJmin"
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false,
            "id": "#outSJfilterDistToOtherSJmin",
            "label": "Min distance to other donor/acceptor",
            "description": "Minimum allowed distance to other junctions' donor/acceptor for each of the motifs (int >= 0). Does not apply to annotated junctions.",
            "sbg:category": "Output filtering: splice junctions"
          },
          {
            "sbg:toolDefaultValue": "3 1 1 1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": " ",
              "prefix": "--outSJfilterCountUniqueMin"
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false,
            "id": "#outSJfilterCountUniqueMin",
            "label": "Min unique count",
            "description": "Minimum uniquely mapping read count per junction for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Junctions are output if one of --outSJfilterCountUniqueMin OR --outSJfilterCountTotalMin conditions are satisfied. Does not apply to annotated junctions.",
            "sbg:category": "Output filtering: splice junctions"
          },
          {
            "sbg:toolDefaultValue": "3 1 1 1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": " ",
              "prefix": "--outSJfilterCountTotalMin"
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false,
            "id": "#outSJfilterCountTotalMin",
            "label": "Min total count",
            "description": "Minimum total (multi-mapping+unique) read count per junction for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Junctions are output if one of --outSJfilterCountUniqueMin OR --outSJfilterCountTotalMin conditions are satisfied. Does not apply to annotated junctions.",
            "sbg:category": "Output filtering: splice junctions"
          },
          {
            "sbg:toolDefaultValue": "None",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMunmapped"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "Within",
                  "Within KeepPairs"
                ],
                "name": "outSAMunmapped",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outSAMunmapped",
            "label": "Write unmapped in SAM",
            "description": "Output of unmapped reads in the SAM format. None: no output Within: output unmapped reads within the main SAM file (i.e. Aligned.out.sam).",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "SAM",
            "inputBinding": {
              "valueFrom": {
                "script": "{\n  SAM_type = $job.inputs.outSAMtype\n  SORT_type = $job.inputs.outSortingType\n  if (SAM_type && SORT_type) {\n    if (SAM_type==\"SAM\") {\n      return \"--outSAMtype SAM\"\n    } else {\n      return \"--outSAMtype \".concat(SAM_type, \" \", SORT_type)\n    }\n  } else if (SAM_type && SORT_type==null) {\n    if (SAM_type==\"SAM\") {\n      return \"--outSAMtype SAM\"\n    } else {\n      return \"--outSAMtype \".concat(SAM_type, \" Unsorted\")\n    }\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "type": [
              "null",
              {
                "symbols": [
                  "SAM",
                  "BAM"
                ],
                "name": "outSAMtype",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outSAMtype",
            "label": "Output format",
            "description": "Format of output alignments.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "None",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMstrandField"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "intronMotif"
                ],
                "name": "outSAMstrandField",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outSAMstrandField",
            "label": "Strand field flag",
            "description": "Cufflinks-like strand field flag. None: not used; intronMotif: strand derived from the intron motif. Reads with inconsistent and/or non-canonical introns are filtered out.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "Standard",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMreadID"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "Standard",
                  "Number"
                ],
                "name": "outSAMreadID",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outSAMreadID",
            "label": "Read ID",
            "description": "Read ID record type. Standard: first word (until space) from the FASTx read ID line, removing /1,/2 from the end; Number: read number (index) in the FASTx file.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "OneBestScore",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMprimaryFlag"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "OneBestScore",
                  "AllBestScore"
                ],
                "name": "outSAMprimaryFlag",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outSAMprimaryFlag",
            "label": "Primary alignments",
            "description": "Which alignments are considered primary - all others will be marked with 0x100 bit in the FLAG. OneBestScore: only one alignment with the best score is primary; AllBestScore: all alignments with the best score are primary.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "Paired",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMorder"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "Paired",
                  "PairedKeepInputOrder"
                ],
                "name": "outSAMorder",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outSAMorder",
            "label": "Sorting in SAM",
            "description": "Type of sorting for the SAM output. Paired: one mate after the other for all paired alignments; PairedKeepInputOrder: one mate after the other for all paired alignments, the order is kept the same as in the input FASTQ files.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "-1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMmultNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#outSAMmultNmax",
            "label": "Max number of multiple alignment",
            "description": "Max number of multiple alignments for a read that will be output to the SAM/BAM files.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "Full",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMmode"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "Full",
                  "NoQS",
                  "None"
                ],
                "name": "outSAMmode",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outSAMmode",
            "label": "SAM mode",
            "description": "Mode of SAM output. Full: full SAM output; NoQS: full SAM but without quality scores.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "255",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMmapqUnique"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#outSAMmapqUnique",
            "label": "MAPQ value",
            "description": "MAPQ value for unique mappers (0 to 255).",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMheaderPG"
            },
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#outSAMheaderPG",
            "label": "SAM header @PG",
            "description": "Extra @PG (software) line of the SAM header (in addition to STAR).",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMheaderHD"
            },
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#outSAMheaderHD",
            "label": "SAM header @HD",
            "description": "@HD (header) line of the SAM header.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMflagOR"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#outSAMflagOR",
            "label": "OR SAM flag",
            "description": "Set specific bits of the SAM FLAG.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "65535",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMflagAND"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#outSAMflagAND",
            "label": "AND SAM flag",
            "description": "Set specific bits of the SAM FLAG.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "None",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMfilter"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "KeepOnlyAddedReferences",
                  "None"
                ],
                "name": "outSAMfilter",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outSAMfilter",
            "label": "Output filter",
            "description": "Filter the output into main SAM/BAM files.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "Standard",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMattributes"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "Standard",
                  "NH",
                  "All",
                  "None"
                ],
                "name": "outSAMattributes",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outSAMattributes",
            "label": "SAM attributes",
            "description": "Desired SAM attributes, in the order desired for the output SAM. NH: any combination in any order; Standard: NH HI AS nM; All: NH HI AS nM NM MD jM jI; None: no attributes.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outSAMattrIHstart"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#outSAMattrIHstart",
            "label": "IH attribute start value",
            "description": "Start value for the IH attribute. 0 may be required by some downstream software, such as Cufflinks or StringTie.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "None",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outReadsUnmapped"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "Fastx"
                ],
                "name": "outReadsUnmapped",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outReadsUnmapped",
            "label": "Output unmapped reads",
            "description": "Output of unmapped reads (besides SAM). None: no output; Fastx: output in separate fasta/fastq files, Unmapped.out.mate1/2.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outQSconversionAdd"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#outQSconversionAdd",
            "label": "Quality conversion",
            "description": "Add this number to the quality score (e.g. to convert from Illumina to Sanger, use -31).",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "Old_2.4",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outMultimapperOrder"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "Random",
                  "Old_2.4"
                ],
                "name": "outMultimapperOrder",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outMultimapperOrder",
            "label": "Order of multimapping alignment",
            "description": "Random option outputs multiple alignments for each read in random order, and also also randomizes the choice of the primary alignment from the highest scoring alignments.",
            "sbg:category": "Output"
          },
          {
            "sbg:toolDefaultValue": "Normal",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterType"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "Normal",
                  "BySJout"
                ],
                "name": "outFilterType",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outFilterType",
            "label": "Filtering type",
            "description": "Type of filtering. Normal: standard filtering using only current alignment; BySJout: keep only those reads that contain junctions that passed filtering into SJ.out.tab.",
            "sbg:category": "Output filtering"
          },
          {
            "sbg:toolDefaultValue": "0.66",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterScoreMinOverLread"
            },
            "type": [
              "null",
              "float"
            ],
            "required": false,
            "id": "#outFilterScoreMinOverLread",
            "label": "Min score normalized",
            "description": "'Minimum score' normalized to read length (sum of mates' lengths for paired-end reads).",
            "sbg:category": "Output filtering"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterScoreMin"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#outFilterScoreMin",
            "label": "Min score",
            "description": "Alignment will be output only if its score is higher than this value.",
            "sbg:category": "Output filtering"
          },
          {
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMultimapScoreRange"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#outFilterMultimapScoreRange",
            "label": "Multimapping score range",
            "description": "The score range below the maximum score for multimapping alignments.",
            "sbg:category": "Output filtering"
          },
          {
            "sbg:toolDefaultValue": "10",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMultimapNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#outFilterMultimapNmax",
            "label": "Max number of mappings",
            "description": "Read alignments will be output only if the read maps fewer than this value, otherwise no alignments will be output.",
            "sbg:category": "Output filtering"
          },
          {
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMismatchNoverReadLmax"
            },
            "type": [
              "null",
              "float"
            ],
            "required": false,
            "id": "#outFilterMismatchNoverReadLmax",
            "label": "Mismatches to *read* length",
            "description": "Alignment will be output only if its ratio of mismatches to *read* length is less than this value.",
            "sbg:category": "Output filtering"
          },
          {
            "sbg:toolDefaultValue": "0.3",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMismatchNoverLmax"
            },
            "type": [
              "null",
              "float"
            ],
            "required": false,
            "id": "#outFilterMismatchNoverLmax",
            "label": "Mismatches to *mapped* length",
            "description": "Alignment will be output only if its ratio of mismatches to *mapped* length is less than this value.",
            "sbg:category": "Output filtering"
          },
          {
            "sbg:toolDefaultValue": "10",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMismatchNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#outFilterMismatchNmax",
            "label": "Max number of mismatches",
            "description": "Alignment will be output only if it has fewer mismatches than this value.",
            "sbg:category": "Output filtering"
          },
          {
            "sbg:toolDefaultValue": "0.66",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMatchNminOverLread"
            },
            "type": [
              "null",
              "float"
            ],
            "required": false,
            "id": "#outFilterMatchNminOverLread",
            "label": "Min matched bases normalized",
            "description": "'Minimum matched bases' normalized to read length (sum of mates lengths for paired-end reads).",
            "sbg:category": "Output filtering"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterMatchNmin"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#outFilterMatchNmin",
            "label": "Min matched bases",
            "description": "Alignment will be output only if the number of matched bases is higher than this value.",
            "sbg:category": "Output filtering"
          },
          {
            "sbg:toolDefaultValue": "None",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--outFilterIntronMotifs"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "RemoveNoncanonical",
                  "RemoveNoncanonicalUnannotated"
                ],
                "name": "outFilterIntronMotifs",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#outFilterIntronMotifs",
            "label": "Motifs filtering",
            "description": "Filter alignment using their motifs. None: no filtering; RemoveNoncanonical: filter out alignments that contain non-canonical junctions; RemoveNoncanonicalUnannotated: filter out alignments that contain non-canonical unannotated junctions when using annotated splice junctions database. The annotated non-canonical junctions will be kept.",
            "sbg:category": "Output filtering"
          },
          {
            "sbg:toolDefaultValue": "Off",
            "type": [
              "null",
              "boolean"
            ],
            "required": false,
            "id": "#no_read_groups",
            "label": "No read groups",
            "description": "If this boolean argument is specified, no read groups will be set in the resulting BAM header.",
            "sbg:category": "Read group"
          },
          {
            "sbg:toolDefaultValue": "1000000",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--limitSjdbInsertNsj"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#limitSjdbInsertNsj",
            "label": "Max insert junctions",
            "description": "Maximum number of junction to be inserted to the genome on the fly at the mapping stage, including those from annotations and those detected in the 1st step of the 2-pass run.",
            "sbg:category": "Limits"
          },
          {
            "sbg:toolDefaultValue": "1000",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--limitOutSJoneRead"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#limitOutSJoneRead",
            "label": "Junctions max number",
            "description": "Max number of junctions for one read (including all multi-mappers).",
            "sbg:category": "Limits"
          },
          {
            "sbg:toolDefaultValue": "1000000",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--limitOutSJcollapsed"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#limitOutSJcollapsed",
            "label": "Collapsed junctions max number",
            "description": "Max number of collapsed junctions.",
            "sbg:category": "Limits"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--limitBAMsortRAM"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#limitBAMsortRAM",
            "label": "Limit BAM sorting memory",
            "description": "Maximum available RAM for sorting BAM. If set to 0, it will be set to the genome index size.",
            "sbg:category": "Limits"
          },
          {
            "sbg:toolDefaultValue": "genomeDir",
            "inputBinding": {
              "valueFrom": {
                "script": "$job.inputs.genomeDirName || \"genomeDir\"",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--genomeDir",
              "position": 0
            },
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#genomeDirName",
            "label": "Genome dir name",
            "description": "Name of the directory which contains genome files (when genome.tar is uncompressed).",
            "sbg:category": "Basic"
          },
          {
            "sbg:fileTypes": "TAR",
            "type": [
              "File"
            ],
            "required": true,
            "id": "#genome",
            "label": "Genome files",
            "description": "Genome files created using STAR Genome Generate.",
            "sbg:category": "Basic"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": " ",
              "prefix": "--clip5pNbases"
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false,
            "id": "#clip5pNbases",
            "label": "Clip 5p bases",
            "description": "Number of bases to clip from 5p of each mate. In case only one value is given, it will be assumed the same for both mates.",
            "sbg:category": "Read parameters"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": " ",
              "prefix": "--clip3pNbases"
            },
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "required": false,
            "id": "#clip3pNbases",
            "label": "Clip 3p bases",
            "description": "Number of bases to clip from 3p of each mate. In case only one value is given, it will be assumed the same for both mates.",
            "sbg:category": "Read parameters"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": " ",
              "prefix": "--clip3pAfterAdapterNbases"
            },
            "type": [
              "null",
              {
                "name": "clip3pAfterAdapterNbases",
                "items": "int",
                "type": "array"
              }
            ],
            "required": false,
            "id": "#clip3pAfterAdapterNbases",
            "label": "Clip 3p after adapter seq",
            "description": "Number of bases to clip from 3p of each mate after the adapter clipping. In case only one value is given, it will be assumed the same for both mates.",
            "sbg:category": "Read parameters"
          },
          {
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": " ",
              "prefix": "--clip3pAdapterSeq"
            },
            "type": [
              "null",
              {
                "items": "string",
                "type": "array"
              }
            ],
            "required": false,
            "id": "#clip3pAdapterSeq",
            "label": "Clip 3p adapter sequence",
            "description": "Adapter sequence to clip from 3p of each mate. In case only one value is given, it will be assumed the same for both mates.",
            "sbg:category": "Read parameters"
          },
          {
            "sbg:toolDefaultValue": "0.1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": " ",
              "prefix": "--clip3pAdapterMMp"
            },
            "type": [
              "null",
              {
                "items": "float",
                "type": "array"
              }
            ],
            "required": false,
            "id": "#clip3pAdapterMMp",
            "label": "Max mismatches proportions",
            "description": "Max proportion of mismatches for 3p adapter clipping for each mate. In case only one value is given, it will be assumed the same for both mates.",
            "sbg:category": "Read parameters"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimSegmentReadGapMax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#chimSegmentReadGapMax",
            "label": "Chimeric segment gap",
            "description": "Maximum gap in the read sequence between chimeric segments (int>=0).",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimSegmentMin"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#chimSegmentMin",
            "label": "Min segment length",
            "description": "Minimum length of chimeric segment length, if =0, no chimeric output (int>=0).",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "sbg:toolDefaultValue": "10",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimScoreSeparation"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#chimScoreSeparation",
            "label": "Min separation score",
            "description": "Minimum difference (separation) between the best chimeric score and the next one (int>=0).",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimScoreMin"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#chimScoreMin",
            "label": "Min total score",
            "description": "Minimum total (summed) score of the chimeric segments (int>=0).",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "sbg:toolDefaultValue": "-1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimScoreJunctionNonGTAG"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#chimScoreJunctionNonGTAG",
            "label": "Non-GT/AG penalty",
            "description": "Penalty for a non-GT/AG chimeric junction.",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "sbg:toolDefaultValue": "20",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimScoreDropMax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#chimScoreDropMax",
            "label": "Max drop score",
            "description": "Max drop (difference) of chimeric score (the sum of scores of all chimeric segements) from the read length (int>=0).",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "sbg:toolDefaultValue": "SeparateSAMold",
            "type": [
              "null",
              {
                "symbols": [
                  "SeparateSAMold",
                  "Within"
                ],
                "name": "chimOutType",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#chimOutType",
            "label": "Chimeric output type",
            "description": "Type of chimeric output. SeparateSAMold: output old SAM into separate Chimeric.out.sam file; Within: output into main aligned SAM/BAM files.",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "sbg:toolDefaultValue": "20",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimJunctionOverhangMin"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#chimJunctionOverhangMin",
            "label": "Min junction overhang",
            "description": "Minimum overhang for a chimeric junction (int>=0).",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "sbg:toolDefaultValue": "banGenomicN",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--chimFilter"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "banGenomicN",
                  "None"
                ],
                "name": "chimFilter",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#chimFilter",
            "label": "Chimeric filter",
            "description": "Different filters for chimeric alignments None no filtering banGenomicN Ns are not allowed in the genome sequence around the chimeric junction.",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "sbg:toolDefaultValue": "10000",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignWindowsPerReadNmax"
            },
            "type": [
              "null",
              "float"
            ],
            "required": false,
            "id": "#alignWindowsPerReadNmax",
            "label": "Max windows per read",
            "description": "Max number of windows per read (int>0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "100",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignTranscriptsPerWindowNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#alignTranscriptsPerWindowNmax",
            "label": "Max transcripts per window",
            "description": "Max number of transcripts per window (int>0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "10000",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignTranscriptsPerReadNmax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#alignTranscriptsPerReadNmax",
            "label": "Max transcripts per read",
            "description": "Max number of different alignments per read to consider (int>0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "0.66",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignSplicedMateMapLminOverLmate"
            },
            "type": [
              "null",
              "float"
            ],
            "required": false,
            "id": "#alignSplicedMateMapLminOverLmate",
            "label": "Min mapped length normalized",
            "description": "AlignSplicedMateMapLmin normalized to mate length (float>0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignSplicedMateMapLmin"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#alignSplicedMateMapLmin",
            "label": "Min mapped length",
            "description": "Minimum mapped length for a read mate that is spliced (int>0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "Yes",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignSoftClipAtReferenceEnds"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "Yes",
                  "No"
                ],
                "name": "alignSoftClipAtReferenceEnds",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#alignSoftClipAtReferenceEnds",
            "label": "Soft clipping",
            "description": "Option which allows soft clipping of alignments at the reference (chromosome) ends. Can be disabled for compatibility with Cufflinks/Cuffmerge. Yes: Enables soft clipping; No: Disables soft clipping.",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "0 -1 0 0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignSJstitchMismatchNmax"
            },
            "type": [
              "null",
              "string"
            ],
            "required": false,
            "id": "#alignSJstitchMismatchNmax",
            "label": "Splice junction stich max mismatch",
            "description": "4*int>=0: maximum number of mismatches for stitching of the splice junctions (-1: no limit). (1) non-canonical motifs, (2) GT/AG and CT/AC motif, (3) GC/AG and CT/GC motif, (4) AT/AC and GT/AT motif.",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "5",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignSJoverhangMin"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#alignSJoverhangMin",
            "label": "Min overhang",
            "description": "Minimum overhang (i.e. block size) for spliced alignments (int>0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "3",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignSJDBoverhangMin"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#alignSJDBoverhangMin",
            "label": "Min overhang: annotated",
            "description": "Minimum overhang (i.e. block size) for annotated (sjdb) spliced alignments (int>0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignMatesGapMax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#alignMatesGapMax",
            "label": "Max mates gap",
            "description": "Maximum gap between two mates, if 0, max intron gap will be determined by (2^winBinNbits)*winAnchorDistNbins.",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "21",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignIntronMin"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#alignIntronMin",
            "label": "Min intron size",
            "description": "Minimum intron size: genomic gap is considered intron if its length >= alignIntronMin, otherwise it is considered Deletion (int>=0).",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignIntronMax"
            },
            "type": [
              "null",
              "int"
            ],
            "required": false,
            "id": "#alignIntronMax",
            "label": "Max intron size",
            "description": "Maximum intron size, if 0, max intron size will be determined by (2^winBinNbits)*winAnchorDistNbins.",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "sbg:toolDefaultValue": "Local",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--alignEndsType"
            },
            "type": [
              "null",
              {
                "symbols": [
                  "Local",
                  "EndToEnd",
                  "Extend5pOfRead1",
                  "Extend3pOfRead1"
                ],
                "name": "alignEndsType",
                "type": "enum"
              }
            ],
            "required": false,
            "id": "#alignEndsType",
            "label": "Alignment type",
            "description": "Type of read ends alignment. Local: standard local alignment with soft-clipping allowed. EndToEnd: force end to end read alignment, do not soft-clip; Extend5pOfRead1: fully extend only the 5p of the read1, all other ends: local alignment.",
            "sbg:category": "Alignments and Seeding"
          }
        ],
        "arguments": [
          {
            "valueFrom": {
              "script": "{\n  file = [].concat($job.inputs.reads)[0].path\n  extension = /(?:\\.([^.]+))?$/.exec(file)[1]\n  if (extension == \"gz\") {\n    return \"--readFilesCommand zcat\"\n  } else if (extension == \"bz2\") {\n    return \"--readFilesCommand bzcat\"\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "script": "{\t\n  var sjFormat = \"False\"\n  var gtfgffFormat = \"False\"\n  var list = $job.inputs.sjdbGTFfile\n  var paths_list = []\n  var joined_paths = \"\"\n  \n  if (list) {\n    list.forEach(function(f){return paths_list.push(f.path)})\n    joined_paths = paths_list.join(\" \")\n\n\n    paths_list.forEach(function(f){\n      ext = f.replace(/^.*\\./, '')\n      if (ext == \"gff\" || ext == \"gtf\") {\n        gtfgffFormat = \"True\"\n        return gtfgffFormat\n      }\n      if (ext == \"txt\") {\n        sjFormat = \"True\"\n        return sjFormat\n      }\n    })\n\n    if ($job.inputs.sjdbGTFfile && $job.inputs.sjdbInsertSave != \"None\") {\n      if (sjFormat == \"True\") {\n        return \"--sjdbFileChrStartEnd \".concat(joined_paths)\n      }\n      else if (gtfgffFormat == \"True\") {\n        return \"--sjdbGTFfile \".concat(joined_paths)\n      }\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "script": "{\n  a = b = c = d = e = f = g = []\n  if ($job.inputs.sjdbGTFchrPrefix) {\n    a = [\"--sjdbGTFchrPrefix\", $job.inputs.sjdbGTFchrPrefix]\n  }\n  if ($job.inputs.sjdbGTFfeatureExon) {\n    b = [\"--sjdbGTFfeatureExon\", $job.inputs.sjdbGTFfeatureExon]\n  }\n  if ($job.inputs.sjdbGTFtagExonParentTranscript) {\n    c = [\"--sjdbGTFtagExonParentTranscript\", $job.inputs.sjdbGTFtagExonParentTranscript]\n  }\n  if ($job.inputs.sjdbGTFtagExonParentGene) {\n    d = [\"--sjdbGTFtagExonParentGene\", $job.inputs.sjdbGTFtagExonParentGene]\n  }\n  if ($job.inputs.sjdbOverhang) {\n    e = [\"--sjdbOverhang\", $job.inputs.sjdbOverhang]\n  }\n  if ($job.inputs.sjdbScore) {\n    f = [\"--sjdbScore\", $job.inputs.sjdbScore]\n  }\n  if ($job.inputs.sjdbInsertSave) {\n    g = [\"--sjdbInsertSave\", $job.inputs.sjdbInsertSave]\n  }\n  \n  \n  \n  if ($job.inputs.sjdbInsertSave != \"None\" && $job.inputs.sjdbGTFfile) {\n    new_list = a.concat(b, c, d, e, f, g)\n    return new_list.join(\" \")\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "script": "{\n  if ($job.inputs.twopassMode == \"Basic\") {\n    if ($job.inputs.twopass1readsN) {\n      return \"--twopass1readsN \".concat($job.inputs.twopass1readsN) \n    } else {\n      return \"--twopass1readsN -1\"\n    }\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "script": "{\n  if ($job.inputs.chimOutType == \"Within\") {\n    return \"--chimOutType \".concat(\"Within\", $job.inputs.outSAMtype)\n  }\n  else {\n    return \"--chimOutType SeparateSAMold\"\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "script": "{\n  if ($job.inputs.no_read_groups) {\n  return \"\" }\n  else {\n  var param_list = []\n  var all_samples = []\n  var list = [].concat($job.inputs.reads)\n  getUnique = function(arr){\n    var u = {}, a = [];\n    for(var i = 0, l = arr.length; i < l; ++i){\n      if(u.hasOwnProperty(arr[i])) {\n        continue;\n      }\n      a.push(arr[i]);\n      u[arr[i]] = 1;\n    }\n    return a;\n  }\n  \n  function add_param(key, value){\n    if (value == \"\") {\n      return\n    }\n    else {\n      return param_list.push(key.concat(\":\", value))\n    }\n  }\n  for (index = 0; index < list.length; ++index) {\n    if (list[index].metadata != null){\n    \tif (list[index].metadata.sample_id != null){\n      \t\tall_samples.push(list[index].metadata.sample_id)\n      }\n    }\n  }\n  \n  samples = getUnique(all_samples)\n  var samples_given = all_samples.length == list.length\n  var all_rg = []\n  if (samples_given){\n    for (sample_ind = 0; sample_ind < samples.length; ++sample_ind){\n    \tfor (read_ind = 0; read_ind < list.length; ++read_ind) {\n        var param_list = []\n        if (list[read_ind].metadata && list[read_ind].metadata.sample_id == samples[sample_ind] && list[read_ind].metadata.paired_end != \"2\") {\n        \tadd_param('ID', samples[sample_ind])\n          if ($job.inputs.rg_seq_center) {\n            add_param('CN', $job.inputs.rg_seq_center)\n          } else if (list[read_ind].metadata && list[read_ind].metadata.seq_center) {\n            add_param('CN', list[read_ind].metadata.seq_center)\n          }\n          if ($job.inputs.rg_library_id) {\n            add_param('LB', $job.inputs.rg_library_id)\n          } else if (list[read_ind].metadata && list[read_ind].metadata.library_id) {\n            add_param('LB', list[read_ind].metadata.library_id)\n          }\n          if ($job.inputs.rg_mfl) {\n            add_param('PI', $job.inputs.rg_mfl)\n          } else if (list[read_ind].metadata && list[read_ind].metadata.median_fragment_length) {\n            add_param('PI', list[read_ind].metadata.median_fragment_length)\n          }\n          if ($job.inputs.rg_platform) {\n            add_param('PL', $job.inputs.rg_platform.replace(/ /g,\"_\"))\n          } else if (list[read_ind].metadata && list[read_ind].metadata.platform) {\n            add_param('PL', list[read_ind].metadata.platform.replace(/ /g,\"_\"))\n          }\n          if ($job.inputs.rg_platform_unit_id) {\n            add_param('PU', $job.inputs.rg_platform_unit_id)\n          } else if (list[read_ind].metadata && list[read_ind].metadata.platform_unit_id) {\n            add_param('PU', list[read_ind].metadata.platform_unit_id)\n          }\n          if ($job.inputs.rg_sample_id) {\n            add_param('SM', $job.inputs.rg_sample_id)\n          } else if (list[read_ind].metadata && list[read_ind].metadata.sample_id) {\n            add_param('SM', list[read_ind].metadata.sample_id)\n          }\n          all_rg.push(param_list.join(\" \"))\n       }\n\n    }\n   }\n  } else {\n  \tvar param_list = []\n    add_param('ID', \"1\")\n    if ($job.inputs.rg_seq_center) {\n      add_param('CN', $job.inputs.rg_seq_center)\n    } else if ([].concat($job.inputs.reads)[0].metadata && [].concat($job.inputs.reads)[0].metadata.seq_center) {\n      add_param('CN', [].concat($job.inputs.reads)[0].metadata.seq_center)\n    }\n    if ($job.inputs.rg_library_id) {\n      add_param('LB', $job.inputs.rg_library_id)\n    } else if ([].concat($job.inputs.reads)[0].metadata && [].concat($job.inputs.reads)[0].metadata.library_id) {\n      add_param('LB', [].concat($job.inputs.reads)[0].metadata.library_id)\n    }\n    if ($job.inputs.rg_mfl) {\n      add_param('PI', $job.inputs.rg_mfl)\n    } else if ([].concat($job.inputs.reads)[0].metadata && [].concat($job.inputs.reads)[0].metadata.median_fragment_length) {\n      add_param('PI', [].concat($job.inputs.reads)[0].metadata.median_fragment_length)\n    }\n    if ($job.inputs.rg_platform) {\n      add_param('PL', $job.inputs.rg_platform.replace(/ /g,\"_\"))\n    } else if ([].concat($job.inputs.reads)[0].metadata && [].concat($job.inputs.reads)[0].metadata.platform) {\n      add_param('PL', [].concat($job.inputs.reads)[0].metadata.platform.replace(/ /g,\"_\"))\n    }\n    if ($job.inputs.rg_platform_unit_id) {\n      add_param('PU', $job.inputs.rg_platform_unit_id)\n    } else if ([].concat($job.inputs.reads)[0].metadata && [].concat($job.inputs.reads)[0].metadata.platform_unit_id) {\n      add_param('PU', [].concat($job.inputs.reads)[0].metadata.platform_unit_id)\n    }\n    if ($job.inputs.rg_sample_id) {\n      add_param('SM', $job.inputs.rg_sample_id)\n    } else if ([].concat($job.inputs.reads)[0].metadata && [].concat($job.inputs.reads)[0].metadata.sample_id) {\n      add_param('SM', [].concat($job.inputs.reads)[0].metadata.sample_id)\n    }\n    return \"--outSAMattrRGline \".concat(param_list.join(\" \"))\n  }\n  return \"--outSAMattrRGline \".concat(all_rg.join(\" , \"))\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "script": "{\n  if ($job.inputs.sjdbGTFfile && $job.inputs.quantMode) {\n    return \"--quantMode \".concat($job.inputs.quantMode)\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  arr = [].concat($job.inputs.reads)\n  arr.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  common_prefix = sharedStart(path_list)\n  intermediate = common_prefix.replace( /\\-$|\\_$|\\.$/, '' ).concat(\"._STARgenome\")\n  source = \"./\".concat(intermediate)\n  destination = intermediate.concat(\".tar\")\n  if ($job.inputs.sjdbGTFfile && $job.inputs.sjdbInsertSave && $job.inputs.sjdbInsertSave != \"None\") {\n    return \"&& tar -vcf \".concat(destination, \" \", source)\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 100
          },
          {
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  arr = [].concat($job.inputs.reads)\n  arr.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  common_prefix = sharedStart(path_list)\n  if (common_prefix == \"\" || common_prefix == \"_\"){\n    common_prefix = \"All\"\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\")\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "--outFileNamePrefix"
          },
          {
            "valueFrom": {
              "script": "{\n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  arr = [].concat($job.inputs.reads)\n  arr.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  common_prefix = sharedStart(path_list)\n  mate1 = common_prefix.replace( /\\-$|\\_$|\\.$/, '' ).concat(\".Unmapped.out.mate1\")\n  mate2 = common_prefix.replace( /\\-$|\\_$|\\.$/, '' ).concat(\".Unmapped.out.mate2\")\n  var x = arr[0].path.split('/').pop()\n  var y = x.toLowerCase()\n  \n  if ($job.inputs.unmappedOutputName) {\n  \tvar output_name = \".\" + $job.inputs.unmappedOutputName + \".\"\n  } else {\n    var output_name = \".Unmapped.out.\"\n  }\n  \n  mate1_1 = common_prefix.replace( /\\-$|\\_$|\\.$/, '' ).concat(output_name + \"mate1\")\n  mate2_1 = common_prefix.replace( /\\-$|\\_$|\\.$/, '' ).concat(output_name + \"mate2\")\n  \n  \n  if (y.endsWith('fastq') || y.endsWith('fq') || y.endsWith('fastq.gz') || y.endsWith('fastq.bz2') || y.endsWith('fq.gz') || y.endsWith('fq.bz2')) { \n    mate1fq = mate1_1.concat(\".fastq\")\n    mate2fq = mate2_1.concat(\".fastq\")\n  } else if (y.endsWith('fasta') || y.endsWith('fa') || y.endsWith('fasta.gz') || y.endsWith('fasta.bz2') || y.endsWith('fa.gz') || y.endsWith('fa.bz2')) {\n    mate1fq = mate1_1.concat(\".fasta\")\n    mate2fq = mate2_1.concat(\".fasta\")\n  }\n\n  \n  if ($job.inputs.sortUnmappedReads) {\n    \n  var cmd = \"\"\n  var sort_cmd = \" | sed 's/\\\\t.*//' | paste - - - - | sort -k1,1 -S 10G | tr '\\\\t' '\\\\n' > \"\n  if ($job.inputs.outReadsUnmapped == \"Fastx\" && arr.length > 1) {\n    cmd = cmd.concat(\" && cat \", mate2, sort_cmd, mate2fq, \" && rm \", mate2)\n  }\n  if ($job.inputs.outReadsUnmapped == \"Fastx\") {\n    cmd = cmd.concat(\" && cat \", mate1, sort_cmd, mate1fq, \" && rm \", mate1)\n  }\n  return cmd\n  \n  } else {\n\n  if ($job.inputs.outReadsUnmapped == \"Fastx\" && arr.length > 1) {\n    return \"&& mv \".concat(mate1, \" \", mate1fq, \" && mv \", mate2, \" \", mate2fq)\n  }\n  else if ($job.inputs.outReadsUnmapped == \"Fastx\" && arr.length == 1) {\n    return \"&& mv \".concat(mate1, \" \", mate1fq)\n  }\n\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 101
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "sample_id": {
                  "script": "{\n \nif([].concat($job.inputs.reads)[0].metadata.sample_id)\n   {\n    return [].concat($job.inputs.reads)[0].metadata.sample_id\n   }\n   else\n   {\n    filename = $self.path.split(\"/\").pop();\n    return filename.split(\".\").shift()\n   }\n}",
                  "class": "Expression",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "script": "{\n  if ($self) {\n    filename = $self.path.split(\"/\").pop();\n    if (filename.lastIndexOf(\".fastq\") !== 0){\n      return filename[filename.lastIndexOf(\".fastq\") - 1 ]\n    } else {\n      return \"\"\n    } \n  } else {\n    return \"\"\n  }\n}",
                  "class": "Expression",
                  "engine": "#cwl-js-engine"
                }
              },
              "sbg:inheritMetadataFrom": "#reads",
              "glob": {
                "script": "{\n  if ($job.inputs.unmappedOutputName) {\n    return \"*\" + $job.inputs.unmappedOutputName + \"*\"\n  } else {\n    return \"*Unmapped.out*\"\n  }\n  \n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "id": "#unmapped_reads",
            "label": "Unmapped reads",
            "description": "Output of unmapped reads.",
            "sbg:fileTypes": "FASTQ"
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "reference_genome": {
                  "script": "{\n  if ($job.inputs.genome.metadata) {\n    if ($job.inputs.genome.metadata.reference_genome) {\n      return $job.inputs.genome.metadata.reference_genome\n    } else {\n      return \"\"\n    }\n  } else {\n  return \"\"\n  }\n}",
                  "class": "Expression",
                  "engine": "#cwl-js-engine"
                }
              },
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*Transcriptome*"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#transcriptome_aligned_reads",
            "label": "Transcriptome alignments",
            "description": "Alignments translated into transcript coordinates.",
            "sbg:fileTypes": "BAM"
          },
          {
            "outputBinding": {
              "sbg:metadata": {},
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*SJ.out.tab"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#splice_junctions",
            "label": "Splice junctions",
            "description": "High confidence collapsed splice junctions in tab-delimited format. Only junctions supported by uniquely mapping reads are reported.",
            "sbg:fileTypes": "TAB"
          },
          {
            "outputBinding": {
              "sbg:metadata": {},
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*ReadsPerGene*"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#reads_per_gene",
            "label": "Reads per gene",
            "description": "File with number of reads per gene. A read is counted if it overlaps (1nt or more) one and only one gene.",
            "sbg:fileTypes": "TAB"
          },
          {
            "outputBinding": {
              "sbg:metadata": {},
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*Log*.out"
            },
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "id": "#log_files",
            "label": "Log files",
            "description": "Log files produced during alignment.",
            "sbg:fileTypes": "OUT"
          },
          {
            "outputBinding": {
              "sbg:metadata": {},
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*_STARgenome.tar"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#intermediate_genome",
            "label": "Intermediate genome files",
            "description": "Archive with genome files produced when annotations are included on the fly (in the mapping step).",
            "sbg:fileTypes": "TAR"
          },
          {
            "outputBinding": {
              "sbg:metadata": {},
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*Chimeric.out.junction"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#chimeric_junctions",
            "label": "Chimeric junctions",
            "description": "If chimSegmentMin in 'Chimeric Alignments' section is set to 0, 'Chimeric Junctions' won't be output.",
            "sbg:fileTypes": "JUNCTION"
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "reference_genome": {
                  "script": "{\n  if ($job.inputs.genome.metadata) {\n    if ($job.inputs.genome.metadata.reference_genome) {\n      return $job.inputs.genome.metadata.reference_genome\n    } else {\n      return \"\"\n    }\n  } else {\n  return \"\"\n  }\n}",
                  "class": "Expression",
                  "engine": "#cwl-js-engine"
                }
              },
              "sbg:inheritMetadataFrom": "#reads",
              "glob": "*.Chimeric.out.sam"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#chimeric_alignments",
            "label": "Chimeric alignments",
            "description": "Aligned Chimeric sequences SAM - if chimSegmentMin = 0, no Chimeric Alignment SAM and Chimeric Junctions outputs.",
            "sbg:fileTypes": "SAM"
          },
          {
            "outputBinding": {
              "sbg:metadata": {
                "sample_id": {
                  "script": "{\n \nif([].concat($job.inputs.reads)[0].metadata.sample_id)\n   {\n    return [].concat($job.inputs.reads)[0].metadata.sample_id\n   }\n   else\n   {\n    filename = $self.path.split(\"/\").pop();\n    return filename.split(\".\").shift()\n   }\n}",
                  "class": "Expression",
                  "engine": "#cwl-js-engine"
                },
                "reference_genome": {
                  "script": "{\n  if ($job.inputs.genome.metadata) {\n    if ($job.inputs.genome.metadata.reference_genome) {\n      return $job.inputs.genome.metadata.reference_genome\n    } else {\n      return \"\"\n    }\n  } else {\n  return \"\"\n  }\n}",
                  "class": "Expression",
                  "engine": "#cwl-js-engine"
                }
              },
              "sbg:inheritMetadataFrom": "#reads",
              "glob": {
                "script": "{\n  if ($job.inputs.outSortingType == 'SortedByCoordinate') {\n    sort_name = '.sortedByCoord'\n  }\n  else {\n    sort_name = ''\n  }\n  if ($job.inputs.outSAMtype == 'BAM') {\n    sam_name = \"*.Aligned\".concat( sort_name, '.out.bam')\n  }\n  else {\n    sam_name = \"*.Aligned.out.sam\"\n  }\n  return sam_name\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#aligned_reads",
            "label": "Aligned SAM/BAM",
            "description": "Aligned sequence in SAM/BAM format.",
            "sbg:fileTypes": "SAM, BAM"
          }
        ],
        "stdin": "",
        "sbg:contributors": [
          "tsang"
        ],
        "id": "krishnanus/initialtesting/star-2-5-1-b/0",
        "sbg:revisionNotes": "Copy of admin/sbg-public-data/star-2-5-1-b/41",
        "sbg:toolkit": "STAR",
        "sbg:toolAuthor": "Alexander Dobin/CSHL",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": "Copy of admin/sbg-public-data/star-2-5-1-b/41",
            "sbg:revision": 0,
            "sbg:modifiedOn": 1499349815
          }
        ],
        "sbg:modifiedOn": 1499349815
      },
      "inputs": [
        {
          "id": "#STAR.winFlankNbins"
        },
        {
          "id": "#STAR.winBinNbits"
        },
        {
          "id": "#STAR.winAnchorMultimapNmax"
        },
        {
          "id": "#STAR.winAnchorDistNbins"
        },
        {
          "id": "#STAR.unmappedOutputName"
        },
        {
          "id": "#STAR.twopassMode"
        },
        {
          "id": "#STAR.twopass1readsN"
        },
        {
          "id": "#STAR.sortUnmappedReads"
        },
        {
          "id": "#STAR.sjdbScore"
        },
        {
          "id": "#STAR.sjdbOverhang"
        },
        {
          "id": "#STAR.sjdbInsertSave"
        },
        {
          "id": "#STAR.sjdbGTFtagExonParentTranscript"
        },
        {
          "id": "#STAR.sjdbGTFtagExonParentGene"
        },
        {
          "id": "#STAR.sjdbGTFfile"
        },
        {
          "id": "#STAR.sjdbGTFfeatureExon"
        },
        {
          "id": "#STAR.sjdbGTFchrPrefix"
        },
        {
          "id": "#STAR.seedSearchStartLmaxOverLread"
        },
        {
          "id": "#STAR.seedSearchStartLmax"
        },
        {
          "id": "#STAR.seedSearchLmax"
        },
        {
          "id": "#STAR.seedPerWindowNmax"
        },
        {
          "id": "#STAR.seedPerReadNmax"
        },
        {
          "id": "#STAR.seedNoneLociPerWindow"
        },
        {
          "id": "#STAR.seedMultimapNmax"
        },
        {
          "id": "#STAR.scoreStitchSJshift"
        },
        {
          "id": "#STAR.scoreInsOpen"
        },
        {
          "id": "#STAR.scoreInsBase"
        },
        {
          "id": "#STAR.scoreGenomicLengthLog2scale"
        },
        {
          "id": "#STAR.scoreGapNoncan"
        },
        {
          "id": "#STAR.scoreGapGCAG"
        },
        {
          "id": "#STAR.scoreGapATAC"
        },
        {
          "id": "#STAR.scoreGap"
        },
        {
          "id": "#STAR.scoreDelOpen"
        },
        {
          "id": "#STAR.scoreDelBase"
        },
        {
          "id": "#STAR.rg_seq_center"
        },
        {
          "id": "#STAR.rg_sample_id"
        },
        {
          "id": "#STAR.rg_platform_unit_id"
        },
        {
          "id": "#STAR.rg_platform"
        },
        {
          "id": "#STAR.rg_mfl"
        },
        {
          "id": "#STAR.rg_library_id"
        },
        {
          "id": "#STAR.reads",
          "source": [
            "#sickle.trimmed_fastq1"
          ]
        },
        {
          "id": "#STAR.readMatesLengthsIn"
        },
        {
          "id": "#STAR.readMapNumber"
        },
        {
          "id": "#STAR.quantTranscriptomeBan"
        },
        {
          "id": "#STAR.quantMode"
        },
        {
          "id": "#STAR.outSortingType"
        },
        {
          "id": "#STAR.outSJfilterReads"
        },
        {
          "id": "#STAR.outSJfilterOverhangMin"
        },
        {
          "id": "#STAR.outSJfilterIntronMaxVsReadN"
        },
        {
          "id": "#STAR.outSJfilterDistToOtherSJmin"
        },
        {
          "id": "#STAR.outSJfilterCountUniqueMin"
        },
        {
          "id": "#STAR.outSJfilterCountTotalMin"
        },
        {
          "id": "#STAR.outSAMunmapped"
        },
        {
          "id": "#STAR.outSAMtype"
        },
        {
          "id": "#STAR.outSAMstrandField"
        },
        {
          "id": "#STAR.outSAMreadID"
        },
        {
          "id": "#STAR.outSAMprimaryFlag"
        },
        {
          "id": "#STAR.outSAMorder"
        },
        {
          "id": "#STAR.outSAMmultNmax"
        },
        {
          "id": "#STAR.outSAMmode"
        },
        {
          "id": "#STAR.outSAMmapqUnique"
        },
        {
          "id": "#STAR.outSAMheaderPG"
        },
        {
          "id": "#STAR.outSAMheaderHD"
        },
        {
          "id": "#STAR.outSAMflagOR"
        },
        {
          "id": "#STAR.outSAMflagAND"
        },
        {
          "id": "#STAR.outSAMfilter"
        },
        {
          "id": "#STAR.outSAMattributes"
        },
        {
          "id": "#STAR.outSAMattrIHstart"
        },
        {
          "default": "Fastx",
          "id": "#STAR.outReadsUnmapped"
        },
        {
          "id": "#STAR.outQSconversionAdd"
        },
        {
          "id": "#STAR.outMultimapperOrder"
        },
        {
          "id": "#STAR.outFilterType"
        },
        {
          "id": "#STAR.outFilterScoreMinOverLread"
        },
        {
          "id": "#STAR.outFilterScoreMin"
        },
        {
          "id": "#STAR.outFilterMultimapScoreRange"
        },
        {
          "id": "#STAR.outFilterMultimapNmax"
        },
        {
          "id": "#STAR.outFilterMismatchNoverReadLmax"
        },
        {
          "id": "#STAR.outFilterMismatchNoverLmax"
        },
        {
          "id": "#STAR.outFilterMismatchNmax"
        },
        {
          "id": "#STAR.outFilterMatchNminOverLread"
        },
        {
          "id": "#STAR.outFilterMatchNmin"
        },
        {
          "id": "#STAR.outFilterIntronMotifs"
        },
        {
          "id": "#STAR.no_read_groups"
        },
        {
          "id": "#STAR.limitSjdbInsertNsj"
        },
        {
          "id": "#STAR.limitOutSJoneRead"
        },
        {
          "id": "#STAR.limitOutSJcollapsed"
        },
        {
          "id": "#STAR.limitBAMsortRAM"
        },
        {
          "id": "#STAR.genomeDirName"
        },
        {
          "id": "#STAR.genome",
          "source": [
            "#genome"
          ]
        },
        {
          "id": "#STAR.clip5pNbases"
        },
        {
          "id": "#STAR.clip3pNbases"
        },
        {
          "id": "#STAR.clip3pAfterAdapterNbases"
        },
        {
          "id": "#STAR.clip3pAdapterSeq"
        },
        {
          "id": "#STAR.clip3pAdapterMMp"
        },
        {
          "id": "#STAR.chimSegmentReadGapMax"
        },
        {
          "id": "#STAR.chimSegmentMin"
        },
        {
          "id": "#STAR.chimScoreSeparation"
        },
        {
          "id": "#STAR.chimScoreMin"
        },
        {
          "id": "#STAR.chimScoreJunctionNonGTAG"
        },
        {
          "id": "#STAR.chimScoreDropMax"
        },
        {
          "id": "#STAR.chimOutType"
        },
        {
          "id": "#STAR.chimJunctionOverhangMin"
        },
        {
          "id": "#STAR.chimFilter"
        },
        {
          "id": "#STAR.alignWindowsPerReadNmax"
        },
        {
          "id": "#STAR.alignTranscriptsPerWindowNmax"
        },
        {
          "id": "#STAR.alignTranscriptsPerReadNmax"
        },
        {
          "id": "#STAR.alignSplicedMateMapLminOverLmate"
        },
        {
          "id": "#STAR.alignSplicedMateMapLmin"
        },
        {
          "id": "#STAR.alignSoftClipAtReferenceEnds"
        },
        {
          "id": "#STAR.alignSJstitchMismatchNmax"
        },
        {
          "id": "#STAR.alignSJoverhangMin"
        },
        {
          "id": "#STAR.alignSJDBoverhangMin"
        },
        {
          "id": "#STAR.alignMatesGapMax"
        },
        {
          "id": "#STAR.alignIntronMin"
        },
        {
          "id": "#STAR.alignIntronMax"
        },
        {
          "id": "#STAR.alignEndsType"
        }
      ],
      "sbg:y": 196.68230040930223,
      "id": "#STAR",
      "outputs": [
        {
          "id": "#STAR.unmapped_reads"
        },
        {
          "id": "#STAR.transcriptome_aligned_reads"
        },
        {
          "id": "#STAR.splice_junctions"
        },
        {
          "id": "#STAR.reads_per_gene"
        },
        {
          "id": "#STAR.log_files"
        },
        {
          "id": "#STAR.intermediate_genome"
        },
        {
          "id": "#STAR.chimeric_junctions"
        },
        {
          "id": "#STAR.chimeric_alignments"
        },
        {
          "id": "#STAR.aligned_reads"
        }
      ],
      "sbg:x": 719.3333605925246
    },
    {
      "run": {
        "temporaryFailCodes": [],
        "baseCommand": [
          "cp",
          "taxonomy.tab",
          "/KronaTools-2.7/taxonomy/.",
          "&&",
          "cp",
          "all.accession2taxid.sorted",
          "/KronaTools-2.7/taxonomy/.",
          "&&",
          "/KronaTools-2.7/scripts/ImportBLAST.pl"
        ],
        "sbg:revision": 0,
        "successCodes": [],
        "y": -63.30729272527003,
        "sbg:job": {
          "inputs": {
            "BLASTinput": {
              "class": "File",
              "path": "/path/to/BLASTinput.ext",
              "secondaryFiles": [],
              "size": 0
            },
            "taxonomytab": {
              "class": "File",
              "path": "/path/to/taxonomytab.ext",
              "secondaryFiles": [],
              "size": 0
            },
            "accession2taxid": {
              "class": "File",
              "path": "/path/to/accession2taxid.ext",
              "secondaryFiles": [],
              "size": 0
            }
          },
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          }
        },
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "sbg:id": "krishnanus/initialtesting/krona-blast/0",
        "sbg:project": "krishnanus/initialtesting",
        "outputs": [
          {
            "id": "#output",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#BLASTinput",
              "glob": "*.html"
            },
            "sbg:fileTypes": "HMTL",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "inputs": [
          {
            "id": "#taxonomytab",
            "required": false,
            "sbg:stageInput": "copy",
            "sbg:fileTypes": "TAB",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "id": "#accession2taxid",
            "required": false,
            "sbg:stageInput": "copy",
            "sbg:fileTypes": "sorted",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "id": "#BLASTinput",
            "required": true,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 1
            },
            "description": "BLAST output tabular format (outfmt 6)",
            "type": [
              "File"
            ]
          }
        ],
        "x": 1271.6666741238691,
        "sbg:cmdPreview": "cp taxonomy.tab /KronaTools-2.7/taxonomy/. && cp all.accession2taxid.sorted /KronaTools-2.7/taxonomy/. && /KronaTools-2.7/scripts/ImportBLAST.pl  /path/to/BLASTinput.ext",
        "sbg:modifiedBy": "tsang",
        "sbg:projectName": "InitialTesting",
        "id": "krishnanus/initialtesting/krona-blast/0",
        "label": "krona_blast",
        "stdout": "",
        "sbg:latestRevision": 0,
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "dockerPull": "stevetsa/krona:latest",
            "class": "DockerRequirement",
            "dockerImageId": ""
          }
        ],
        "requirements": [],
        "cwlVersion": "sbg:draft-2",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "sbg:createdOn": 1499908502,
        "description": "",
        "arguments": [],
        "sbg:copyOf": "tsang/test-microbiome/krona-blast/5",
        "sbg:createdBy": "tsang",
        "sbg:contributors": [
          "tsang"
        ],
        "stdin": "",
        "sbg:revisionNotes": "Copy of tsang/test-microbiome/krona-blast/5",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": "Copy of tsang/test-microbiome/krona-blast/5",
            "sbg:revision": 0,
            "sbg:modifiedOn": 1499908502
          }
        ],
        "sbg:modifiedOn": 1499908502
      },
      "inputs": [
        {
          "id": "#krona_blast.taxonomytab",
          "source": [
            "#taxonomytab"
          ]
        },
        {
          "id": "#krona_blast.accession2taxid",
          "source": [
            "#accession2taxid"
          ]
        },
        {
          "id": "#krona_blast.BLASTinput",
          "source": [
            "#blast.output"
          ]
        }
      ],
      "sbg:y": -63.30729272527003,
      "id": "#krona_blast",
      "outputs": [
        {
          "id": "#krona_blast.output"
        }
      ],
      "sbg:x": 1271.6666741238691
    },
    {
      "run": {
        "temporaryFailCodes": [],
        "baseCommand": [
          "sickle"
        ],
        "sbg:revision": 12,
        "successCodes": [],
        "y": 123.35937990186122,
        "sbg:job": {
          "inputs": {
            "score_type": "illumina",
            "output": "output-string-value",
            "fastq2": {
              "class": "File",
              "path": "fastq2.ext",
              "secondaryFiles": [],
              "size": 0
            },
            "score_cutoff": 33,
            "seqtech": "pe",
            "length_cutoff": 10,
            "fastq1": {
              "class": "File",
              "path": "fastq1.ext",
              "secondaryFiles": [],
              "size": 0
            }
          },
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          }
        },
        "sbg:id": "krishnanus/initialtesting/sickle/12",
        "sbg:validationErrors": [],
        "sbg:toolkitVersion": "2011",
        "sbg:project": "krishnanus/initialtesting",
        "outputs": [
          {
            "id": "#trimmed_fastq2",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#fastq2",
              "glob": "*trimmed_2.fastq"
            },
            "sbg:fileTypes": "FASTQ",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "id": "#trimmed_fastq1",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#fastq1",
              "glob": "*trimmed_1.fastq"
            },
            "sbg:fileTypes": "FASTQ",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "id": "#single_fastq",
            "outputBinding": {
              "glob": "*single.fastq"
            },
            "sbg:fileTypes": "FASTQ",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "inputs": [
          {
            "id": "#seqtech",
            "inputBinding": {
              "valueFrom": {
                "script": "{\n  SEQtech = $job.inputs.seqtech\n  \n  if (SEQtech == \"se\"){\n    FASTQ1 = [].concat($job.inputs.fastq1)[0].path\n    return \"se -f \".concat(FASTQ1)\n  } else{\n    if (SEQtech == \"pe\"){\n      FASTQ1 = [].concat($job.inputs.fastq1)[0].path\n      FASTQ2 = [].concat($job.inputs.fastq2)[0].path\n      return \"pe -f \".concat(FASTQ1, \" -r \", FASTQ2)\n    }\n  \n  }    \n \n  \n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 0
            },
            "description": "single end or pair end",
            "type": [
              {
                "symbols": [
                  "se",
                  "pe"
                ],
                "name": "seqtech",
                "type": "enum"
              }
            ]
          },
          {
            "sbg:toolDefaultValue": "sanger",
            "id": "#score_type",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-t",
              "position": 3
            },
            "sbg:stageInput": null,
            "type": [
              {
                "symbols": [
                  "illumina",
                  "sanger"
                ],
                "name": "score_type",
                "type": "enum"
              }
            ]
          },
          {
            "id": "#score_cutoff",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-q",
              "position": 4
            },
            "type": [
              "null",
              "int"
            ]
          },
          {
            "id": "#output",
            "inputBinding": {
              "valueFrom": {
                "script": "{\n  SEQtech = $job.inputs.seqtech\n  \n  if (SEQtech == \"se\"){\n    FASTQ1 = [].concat($job.inputs.fastq1)[0].path.split(\".\")[0]+ \"_trimmed_1.fastq\"\n    return \"-o \".concat(FASTQ1)\n  }else{\n    if (SEQtech == \"pe\"){\n      FASTQ1 = [].concat($job.inputs.fastq1)[0].path.split(\".\")[0]+ \"_trimmed_1.fastq\"\n      FASTQ2 = [].concat($job.inputs.fastq1)[0].path.split(\".\")[0]+ \"_trimmed_2.fastq\"\n      FASTQS = [].concat($job.inputs.fastq1)[0].path.split(\".\")[0]+ \"_trimmed_S.fastq\"\n      return \"-o \".concat(FASTQ1, \" -p \", FASTQ2, \" -s \", FASTQS) \n    } \n  }\n\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 6
            },
            "type": [
              "null",
              "string"
            ]
          },
          {
            "sbg:toolDefaultValue": "10",
            "id": "#length_cutoff",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-l",
              "position": 5
            },
            "type": [
              "null",
              "int"
            ]
          },
          {
            "id": "#fastq2",
            "required": false,
            "sbg:stageInput": "link",
            "sbg:fileTypes": "FASTQ.GZ",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "id": "#fastq1",
            "required": true,
            "sbg:stageInput": "link",
            "sbg:fileTypes": "FASTQ.GZ",
            "type": [
              "File"
            ]
          }
        ],
        "x": 478.333362513119,
        "sbg:cmdPreview": "sickle  pe -f fastq1.ext -r fastq2.ext -t illumina",
        "sbg:modifiedBy": "tsang",
        "sbg:projectName": "InitialTesting",
        "id": "krishnanus/initialtesting/sickle/12",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:sbgMaintained": false,
        "stdout": "",
        "sbg:latestRevision": 12,
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "dockerPull": "cgc-images.sbgenomics.com/tsang/sickle:2011",
            "class": "DockerRequirement",
            "dockerImageId": ""
          }
        ],
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "class": "ExpressionEngineRequirement"
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "arguments": [],
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "sbg:createdOn": 1500047916,
        "description": "https://github.com/najoshi/sickle\n\nsickle pe -f 1.fastq.gz -r 2.fastq.gz -t sanger -o trimmed_1.fastq -p trimmed_2.fastq -s single.fastq -q (score cutoff) -l (read length cutoff)",
        "label": "sickle",
        "sbg:createdBy": "tsang",
        "sbg:contributors": [
          "tsang"
        ],
        "stdin": "",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": "Copy of pisitkut/snake-genome/sickle/2",
            "sbg:revision": 0,
            "sbg:modifiedOn": 1500047916
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 1,
            "sbg:modifiedOn": 1500052958
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 2,
            "sbg:modifiedOn": 1500305996
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 3,
            "sbg:modifiedOn": 1500306059
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 4,
            "sbg:modifiedOn": 1500306158
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 5,
            "sbg:modifiedOn": 1500306880
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 6,
            "sbg:modifiedOn": 1500307006
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 7,
            "sbg:modifiedOn": 1500307162
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 8,
            "sbg:modifiedOn": 1500307555
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 9,
            "sbg:modifiedOn": 1500312309
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 10,
            "sbg:modifiedOn": 1500314173
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 11,
            "sbg:modifiedOn": 1500385659
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 12,
            "sbg:modifiedOn": 1500551999
          }
        ],
        "sbg:modifiedOn": 1500551999
      },
      "inputs": [
        {
          "default": "se",
          "id": "#sickle.seqtech"
        },
        {
          "default": "sanger",
          "id": "#sickle.score_type"
        },
        {
          "default": 33,
          "id": "#sickle.score_cutoff"
        },
        {
          "id": "#sickle.output"
        },
        {
          "id": "#sickle.length_cutoff"
        },
        {
          "id": "#sickle.fastq2",
          "source": [
            "#fastq2"
          ]
        },
        {
          "id": "#sickle.fastq1",
          "source": [
            "#fastq1"
          ]
        }
      ],
      "sbg:y": 123.35937990186122,
      "id": "#sickle",
      "outputs": [
        {
          "id": "#sickle.trimmed_fastq2"
        },
        {
          "id": "#sickle.trimmed_fastq1"
        },
        {
          "id": "#sickle.single_fastq"
        }
      ],
      "sbg:x": 478.333362513119
    },
    {
      "run": {
        "temporaryFailCodes": [],
        "baseCommand": [
          "megahit",
          "-o",
          "output"
        ],
        "sbg:revision": 10,
        "successCodes": [],
        "y": 69.35420631120758,
        "sbg:job": {
          "inputs": {
            "preset": "meta-sensitive",
            "out_prefix": "out_prefix-string-value",
            "fastq2": {
              "class": "File",
              "path": "/path/to/fastq2.ext",
              "secondaryFiles": [],
              "size": 0
            },
            "fastq1": {
              "class": "File",
              "path": "/path/to/fastq1.ext",
              "secondaryFiles": [],
              "size": 0
            },
            "SeqType": "single-end"
          },
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          }
        },
        "sbg:id": "krishnanus/initialtesting/megahit2/10",
        "sbg:validationErrors": [],
        "sbg:toolkitVersion": "2014",
        "sbg:project": "krishnanus/initialtesting",
        "outputs": [
          {
            "id": "#optx",
            "outputBinding": {
              "glob": "output/*.txt"
            },
            "sbg:fileTypes": "TXT",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "id": "#final_contigs",
            "outputBinding": {
              "glob": "output/*.fa"
            },
            "sbg:fileTypes": "FA, FASTA",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "inputs": [
          {
            "sbg:toolDefaultValue": "meta",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--presets",
              "position": 1
            },
            "type": [
              "null",
              {
                "symbols": [
                  "meta",
                  "meta-sensitive",
                  "meta-large",
                  "bulk",
                  "single-cell"
                ],
                "name": "preset",
                "type": "enum"
              }
            ],
            "sbg:stageInput": null,
            "id": "#preset",
            "description": "MEGAHIT --presets option provides five preset parameter combinations:  {meta} - General metagenome assembly, such as guts; {meta-sensitive} - More sensitive metagenome assembly, but slower; {meta-large} - Large and complex metagenome assembly, such as soil; {bulk} - Experimental; assembly of standard bulk sequencing with sufficient depth; {single-cell} - Experimental; single-cell sequence assembly.  To fine tune parameters for specific datasets, please find our suggestions on this wiki page."
          },
          {
            "id": "#out_prefix",
            "inputBinding": {
              "valueFrom": {
                "script": "{\n  FASTQname = [].concat($job.inputs.fastq1)[0].path.split(\"/\").pop()\n  return FASTQname\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--out-prefix",
              "position": 3
            },
            "type": [
              "null",
              "string"
            ]
          },
          {
            "id": "#fastq2",
            "type": [
              "null",
              "File"
            ],
            "sbg:stageInput": "copy",
            "required": false
          },
          {
            "id": "#fastq1",
            "type": [
              "File"
            ],
            "sbg:stageInput": "copy",
            "required": true
          },
          {
            "id": "#SeqType",
            "inputBinding": {
              "valueFrom": {
                "script": " {\n  SEQtype = $job.inputs.SeqType\n  \n  if (SEQtype==\"pair-end\") {\n    FASTQ1 = [].concat($job.inputs.fastq1)[0].path.split(\"/\").pop()\n    FASTQ2 = [].concat($job.inputs.fastq2)[0].path.split(\"/\").pop()\n    return \"-1 \".concat(FASTQ1, \" -2 \", FASTQ2)\n  }else{\n  \n    if (SEQtype==\"single-end\") {\n    \n      FASTQ1 = [].concat($job.inputs.fastq1)[0].path.split(\"/\").pop()\n    \n      return \"-r \".concat(FASTQ1)\n    } else{\n      \n        if (SEQtype==\"interleaved-pair-end\") {    \n          FASTQ1 = [].concat($job.inputs.fastq1)[0].path.split(\"/\").pop()\n          return \"-12 \".concat(FASTQ1)\n        }\n   \n      }\n  }\n }",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 2
            },
            "description": "./megahit [options] {-1 <pe_1.fq> -2 <pe_2.fq> | --12 <pe12.fq> | -r <se.fq>} -1/-2, --12 and -r are parameters for inputting paired-end, interleaved-paired-end and single-end files. They accept files in fasta (.fasta, .fa, .fna) or fastq (.fastq, .fq) formats. They also supports gzip files (with .gz extensions) and bzip2 files (with .bz2 extensions). Please run ./megahit -h for detailed usage message.",
            "type": [
              {
                "symbols": [
                  "pair-end",
                  "interleaved-pair-end",
                  "single-end"
                ],
                "name": "SeqType",
                "type": "enum"
              }
            ]
          }
        ],
        "x": 739.3336881664197,
        "sbg:cmdPreview": "megahit -o output  -r fastq1.ext",
        "sbg:modifiedBy": "tsang",
        "sbg:projectName": "InitialTesting",
        "id": "krishnanus/initialtesting/megahit2/10",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:sbgMaintained": false,
        "stdout": "",
        "sbg:latestRevision": 10,
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "dockerPull": "cgc-images.sbgenomics.com/tsang/megahit:2014",
            "class": "DockerRequirement",
            "dockerImageId": ""
          }
        ],
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "class": "ExpressionEngineRequirement"
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "arguments": [],
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "sbg:createdOn": 1499796704,
        "description": "https://github.com/voutcn/megahit\nIn this version of the tool, individual output files are created.\nOutput folder\ndone \nfinal.contigs.fa \nintermediate_contigs/ \nlog \nopts.txt\n\n>k41_123 flag=1 multi=6.1220 len=246\nAACAGGTGGAAACATTTGTGAGCTGGAAGAATTAAATTACAAAAGAAAGGAATAAAAAATTGAATAGCGAAACCGAGTAGAACGGTCACTGTATTTTTAAAGTTGAAAGTATGGTGACCGTTTCTTTTTAATTTTAAAGTAAAATAAATTGCACATTCTACGAATTAAGAGTAAAATTTTATAAATAGTGAAAAACGGGATGAAACAGGGAGAAAAAATGTTAAAAAAATTAACGCAACAGGCTAC",
        "label": "megahit",
        "sbg:createdBy": "tsang",
        "sbg:contributors": [
          "tsang"
        ],
        "stdin": "",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": "Copy of tsang/microbiome/megahit2/11",
            "sbg:revision": 0,
            "sbg:modifiedOn": 1499796704
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": "set SeqType required input",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1499802717
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 2,
            "sbg:modifiedOn": 1499802909
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 3,
            "sbg:modifiedOn": 1499803025
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 4,
            "sbg:modifiedOn": 1499804306
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 5,
            "sbg:modifiedOn": 1499806049
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 6,
            "sbg:modifiedOn": 1499865081
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": "copy files",
            "sbg:revision": 7,
            "sbg:modifiedOn": 1499866285
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 8,
            "sbg:modifiedOn": 1499880150
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 9,
            "sbg:modifiedOn": 1500048156
          },
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": null,
            "sbg:revision": 10,
            "sbg:modifiedOn": 1500556981
          }
        ],
        "sbg:modifiedOn": 1500556981
      },
      "inputs": [
        {
          "id": "#megahit.preset",
          "source": [
            "#preset"
          ]
        },
        {
          "id": "#megahit.out_prefix"
        },
        {
          "id": "#megahit.fastq2"
        },
        {
          "id": "#megahit.fastq1",
          "source": [
            "#STAR.unmapped_reads"
          ]
        },
        {
          "id": "#megahit.SeqType",
          "source": [
            "#SeqType"
          ]
        }
      ],
      "sbg:y": 69.35420631120758,
      "id": "#megahit",
      "outputs": [
        {
          "id": "#megahit.optx"
        },
        {
          "id": "#megahit.final_contigs"
        }
      ],
      "sbg:x": 739.3336881664197
    },
    {
      "run": {
        "temporaryFailCodes": [],
        "baseCommand": [
          "mkdir",
          {
            "script": "$job.inputs.database.path.split(\"/\").pop().split(\".\")[0]",
            "class": "Expression",
            "engine": "#cwl-js-engine"
          },
          "&&",
          "tar",
          "xzvf",
          {
            "script": "$job.inputs.database.path.split(\"/\").pop()",
            "class": "Expression",
            "engine": "#cwl-js-engine"
          },
          "-C",
          {
            "script": "$job.inputs.database.path.split(\"/\").pop().split(\".\")[0]",
            "class": "Expression",
            "engine": "#cwl-js-engine"
          },
          "&&",
          "blastn"
        ],
        "sbg:revision": 0,
        "successCodes": [],
        "y": -1.6406238995906133,
        "sbg:job": {
          "inputs": {
            "outfmt": 5,
            "max_hsps": 1,
            "contigs": {
              "class": "File",
              "path": "final.contigs.fa",
              "secondaryFiles": [],
              "size": 0
            },
            "max_target_seqs": 0,
            "database": {
              "class": "File",
              "path": "16SMicrobial.tar.gz",
              "secondaryFiles": [],
              "size": 0
            }
          },
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          }
        },
        "sbg:validationErrors": [],
        "sbg:id": "krishnanus/kawasaki-japan/blast/0",
        "sbg:project": "krishnanus/kawasaki-japan",
        "outputs": [
          {
            "id": "#output",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#contigs",
              "glob": "*.xml"
            },
            "sbg:fileTypes": "XML",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "inputs": [
          {
            "sbg:toolDefaultValue": "5",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-outfmt",
              "position": 5
            },
            "type": [
              "int"
            ],
            "id": "#outfmt",
            "label": "output format",
            "description": "0 = pairwise, 1 = query-anchored showing identities; 2 = query-anchored no identities; 3 = flat query-anchored, show identities; 4 = flat query-anchored, no identities; 5 = XML Blast output; 6 = tabular; 7 = tabular with comment lines; 8 = Text ASN.1; 9 = Binary ASN.1; 10 = Comma-separated values; 11 = BLAST archive format (ASN.1)"
          },
          {
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-max_target_seqs",
              "position": 2
            },
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null,
            "id": "#max_target_seqs",
            "description": "maximum number of targets"
          },
          {
            "sbg:toolDefaultValue": "1",
            "id": "#max_hsps",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-max_hsps",
              "position": 3
            },
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "script": "$job.inputs.database.path.split(\"/\").pop().split(\".\")[0] + \"/\" + $job.inputs.database.path.split(\"/\").pop().split(\".\")[0]",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-db",
              "position": 0
            },
            "type": [
              "File"
            ],
            "sbg:stageInput": "copy",
            "id": "#database",
            "sbg:fileTypes": "TAR.GZ",
            "required": true
          },
          {
            "id": "#contigs",
            "required": true,
            "type": [
              "File"
            ],
            "sbg:fileTypes": "FASTA",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-query",
              "position": 1
            }
          }
        ],
        "x": 956.6667856640324,
        "sbg:cmdPreview": "mkdir 16SMicrobial && tar xzvf 16SMicrobial.tar.gz -C 16SMicrobial && blastn -db 16SMicrobial/16SMicrobial -query final.contigs.fa -outfmt 5 > final.contigs_blast.xml",
        "sbg:modifiedBy": "tsang",
        "sbg:projectName": "Kawasaki_Japan",
        "id": "krishnanus/kawasaki-japan/blast/0",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:sbgMaintained": false,
        "stdout": {
          "script": "$job.inputs.contigs.path.split(\"/\").pop().split(\".fa\")[0] + \"_blast.xml\"",
          "class": "Expression",
          "engine": "#cwl-js-engine"
        },
        "sbg:latestRevision": 0,
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "dockerPull": "cgc-images.sbgenomics.com/tsang/blast:2.4.0",
            "class": "DockerRequirement",
            "dockerImageId": ""
          }
        ],
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "class": "ExpressionEngineRequirement"
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "arguments": [],
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "sbg:createdOn": 1500825541,
        "description": "https://www.ncbi.nlm.nih.gov/books/NBK279690/\nftp://ftp.ncbi.nlm.nih.gov/blast/db/\ninput 16SMicrobial.tar.gz\nfinal.contigs.fa\n\nblastn -db 16SMicrobial -query final.contigs.fa -outfmt 5 > blast.ERR011087_2contigs.out",
        "label": "blast",
        "sbg:copyOf": "krishnanus/initialtesting/blast/5",
        "sbg:createdBy": "tsang",
        "sbg:contributors": [
          "tsang"
        ],
        "stdin": "",
        "sbg:revisionNotes": "Copy of krishnanus/initialtesting/blast/5",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": "Copy of krishnanus/initialtesting/blast/5",
            "sbg:revision": 0,
            "sbg:modifiedOn": 1500825541
          }
        ],
        "sbg:modifiedOn": 1500825541
      },
      "inputs": [
        {
          "default": 6,
          "id": "#blast.outfmt"
        },
        {
          "default": 1,
          "id": "#blast.max_target_seqs"
        },
        {
          "default": 1,
          "id": "#blast.max_hsps"
        },
        {
          "id": "#blast.database",
          "source": [
            "#database_1"
          ]
        },
        {
          "id": "#blast.contigs",
          "source": [
            "#megahit.final_contigs"
          ]
        }
      ],
      "sbg:y": -1.6406238995906133,
      "id": "#blast",
      "outputs": [
        {
          "id": "#blast.output"
        }
      ],
      "sbg:x": 956.6667856640324
    },
    {
      "run": {
        "temporaryFailCodes": [],
        "baseCommand": [
          "fastqc"
        ],
        "sbg:revision": 0,
        "successCodes": [],
        "y": 390.0260416666669,
        "sbg:job": {
          "inputs": {
            "input_fastq": [
              {
                "class": "File",
                "path": "/path/to/input_fastq-1.fastq",
                "secondaryFiles": [],
                "size": 0
              },
              {
                "class": "File",
                "path": "/path/to/input_fastq-2.fastq",
                "secondaryFiles": [],
                "size": 0
              }
            ],
            "quiet": true,
            "format": null,
            "memory_per_job": null,
            "threads": null,
            "cpus_per_job": null
          },
          "allocatedResources": {
            "mem": 1624,
            "cpu": 2
          }
        },
        "sbg:id": "krishnanus/kawasaki-japan/fastqc-0-11-4/0",
        "sbg:validationErrors": [],
        "sbg:toolkitVersion": "0.11.4",
        "sbg:project": "krishnanus/kawasaki-japan",
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "input_fastq"
              },
              "sbg:inheritMetadataFrom": "#input_fastq",
              "glob": "*_fastqc.zip"
            },
            "type": [
              "null",
              {
                "name": "report_zip",
                "items": "File",
                "type": "array"
              }
            ],
            "id": "#report_zip",
            "label": "Report zip",
            "description": "Zip archive of the report.",
            "sbg:fileTypes": "ZIP"
          }
        ],
        "sbg:copyOf": "admin/sbg-public-data/fastqc-0-11-4/8",
        "inputs": [
          {
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "valueFrom": {
                "script": "{\n//if \"threads\" is not specified\n//number of threads is determined based on number of inputs\n  if (! $job.inputs.threads){\n    $job.inputs.threads = [].concat($job.inputs.input_fastq).length\n  }\n  return Math.min($job.inputs.threads,7)\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--threads"
            },
            "sbg:altPrefix": "-t",
            "id": "#threads",
            "sbg:category": "Options",
            "label": "Threads",
            "description": "Specifies the number of files which can be processed simultaneously.  Each thread will be allocated 250MB of memory so you shouldn't run more threads than your available memory will cope with, and not more than 6 threads on a 32 bit machine.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--quiet"
            },
            "sbg:altPrefix": "-q",
            "id": "#quiet",
            "sbg:category": "Options",
            "label": "Quiet",
            "description": "Supress all progress messages on stdout and only report errors.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": false,
              "prefix": "--nogroup"
            },
            "type": [
              "null",
              "boolean"
            ],
            "id": "#nogroup",
            "label": "Nogroup",
            "description": "Disable grouping of bases for reads >50bp. All reports will show data for every base in the read.  WARNING: Using this option will cause fastqc to crash and burn if you use it on really long reads, and your plots may end up a ridiculous size. You have been warned.",
            "sbg:category": "Options"
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": false,
              "prefix": "--nano"
            },
            "type": [
              "null",
              "boolean"
            ],
            "id": "#nano",
            "label": "Nano",
            "description": "Files come from naopore sequences and are in fast5 format. In this mode you can pass in directories to process and the program will take in all fast5 files within those directories and produce a single output file from the sequences found in all files.",
            "sbg:category": "Options"
          },
          {
            "sbg:toolDefaultValue": "Determined by the number of input files",
            "type": [
              "null",
              "int"
            ],
            "id": "#memory_per_job",
            "label": "Amount of memory allocated per job execution.",
            "description": "Amount of memory allocated per execution of FastQC job.",
            "sbg:category": "Execution parameters"
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--limits"
            },
            "sbg:fileTypes": "TXT",
            "sbg:altPrefix": "-l",
            "required": false,
            "id": "#limits_file",
            "sbg:category": "File inputs",
            "label": "Limits",
            "description": "Specifies a non-default file which contains a set of criteria which will be used to determine the warn/error limits for the various modules.  This file can also be used to selectively remove some modules from the output all together.  The format needs to mirror the default limits.txt file found in the Configuration folder.",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "sbg:toolDefaultValue": "7",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--kmers"
            },
            "sbg:altPrefix": "-f",
            "id": "#kmers",
            "sbg:category": "Options",
            "label": "Kmers",
            "description": "Specifies the length of Kmer to look for in the Kmer content module. Specified Kmer length must be between 2 and 10. Default length is 7 if not specified.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": null,
              "position": 100
            },
            "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ, BAM, SAM",
            "type": [
              {
                "name": "input_fastq",
                "items": "File",
                "type": "array"
              }
            ],
            "required": true,
            "id": "#input_fastq",
            "label": "Input file",
            "description": "Input file.",
            "sbg:category": "File inputs"
          },
          {
            "sbg:toolDefaultValue": "FASTQ",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--format"
            },
            "sbg:altPrefix": "-f",
            "id": "#format",
            "sbg:category": "Options",
            "label": "Format",
            "description": "Bypasses the normal sequence file format detection and forces the program to use the specified format.  Valid formats are BAM, SAM, BAM_mapped, SAM_mapped and FASTQ.",
            "type": [
              "null",
              {
                "symbols": [
                  "bam",
                  "sam",
                  "bam_mapped",
                  "sam_mapped",
                  "fastq"
                ],
                "name": "format",
                "type": "enum"
              }
            ]
          },
          {
            "sbg:toolDefaultValue": "Determined by the number of input files",
            "type": [
              "null",
              "int"
            ],
            "id": "#cpus_per_job",
            "label": "Number of CPUs.",
            "description": "Number of CPUs to be allocated per execution of FastQC.",
            "sbg:category": "Execution parameters"
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--contaminants"
            },
            "sbg:fileTypes": "TXT",
            "sbg:altPrefix": "-c",
            "required": false,
            "id": "#contaminants_file",
            "sbg:category": "File inputs",
            "label": "Contaminants",
            "description": "Specifies a non-default file which contains the list of contaminants to screen overrepresented sequences against. The file must contain sets of named contaminants in the form name[tab]sequence.  Lines prefixed with a hash will be ignored.",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": false,
              "prefix": "--casava"
            },
            "type": [
              "null",
              "boolean"
            ],
            "id": "#casava",
            "label": "Casava",
            "description": "Files come from raw casava output. Files in the same sample group (differing only by the group number) will be analysed as a set rather than individually. Sequences with the filter flag set in the header will be excluded from the analysis. Files must have the same names given to them by casava (including being gzipped and ending with .gz) otherwise they won't be grouped together correctly.",
            "sbg:category": "Options"
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--adapters"
            },
            "sbg:fileTypes": "TXT",
            "sbg:altPrefix": "-a",
            "required": false,
            "id": "#adapters_file",
            "sbg:category": "File inputs",
            "label": "Adapters",
            "description": "Specifies a non-default file which contains the list of adapter sequences which will be explicity searched against the library. The file must contain sets of named adapters in the form name[tab]sequence.  Lines prefixed with a hash will be ignored.",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "x": 520.0000000000003,
        "sbg:createdBy": "tsang",
        "sbg:links": [
          {
            "id": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc/",
            "label": "Homepage"
          },
          {
            "id": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.11.4_source.zip",
            "label": "Source Code"
          },
          {
            "id": "https://wiki.hpcc.msu.edu/display/Bioinfo/FastQC+Tutorial",
            "label": "Wiki"
          },
          {
            "id": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.11.4.zip",
            "label": "Download"
          },
          {
            "id": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc",
            "label": "Publication"
          }
        ],
        "sbg:modifiedBy": "tsang",
        "arguments": [
          {
            "valueFrom": "--noextract",
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": ".",
            "separate": true,
            "prefix": "--outdir"
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:license": "GNU General Public License v3.0 only",
        "label": "FastQC",
        "sbg:cmdPreview": "fastqc  --noextract --outdir .  /path/to/input_fastq-1.fastq  /path/to/input_fastq-2.fastq",
        "stdout": "",
        "sbg:categories": [
          "FASTQ-Processing",
          "Quality-Control",
          "Quantification"
        ],
        "sbg:latestRevision": 0,
        "hints": [
          {
            "dockerPull": "images.sbgenomics.com/mladenlsbg/fastqc:0.11.4",
            "class": "DockerRequirement",
            "dockerImageId": "759c4c8fbafd"
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n  // if cpus_per_job is set, it takes precedence\n  if ($job.inputs.cpus_per_job) {\n    return $job.inputs.cpus_per_job \n  }\n  // if threads parameter is set, the number of CPUs is set based on that parametere\n  else if ($job.inputs.threads) {\n    return $job.inputs.threads\n  }\n  // else the number of CPUs is determined by the number of input files, up to 7 -- default\n  else return Math.min([].concat($job.inputs.input_fastq).length,7)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "class": "sbg:MemRequirement",
            "value": {
              "script": "{\n  // if memory_per_job is set, it takes precedence\n  if ($job.inputs.memory_per_job){\n    return $job.inputs.memory_per_job\n  }\n  // if threads parameter is set, memory req is set based on the number of threads\n  else if ($job.inputs.threads){\n    return 1024 + 300*$job.inputs.threads\n  }\n  // else the memory req is determined by the number of input files, up to 7 -- default\n  else return (1024 + 300*Math.min([].concat($job.inputs.input_fastq).length,7))\n}\n\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "class": "ExpressionEngineRequirement"
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "sbg:createdOn": 1500830025,
        "description": "FastQC reads a set of sequence files and produces a quality control (QC) report from each one. These reports consist of a number of different modules, each of which will help identify a different type of potential problem in your data. \n\nSince it's necessary to convert the tool report in order to show them on Seven Bridges platform, it's recommended to use [FastQC Analysis workflow instead](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/fastqc-analysis/). \n\nFastQC is a tool which takes a FASTQ file and runs a series of tests on it to generate a comprehensive QC report.  This report will tell you if there is anything unusual about your sequence.  Each test is flagged as a pass, warning, or fail depending on how far it departs from what you would expect from a normal large dataset with no significant biases.  It is important to stress that warnings or even failures do not necessarily mean that there is a problem with your data, only that it is unusual.  It is possible that the biological nature of your sample means that you would expect this particular bias in your results.\n\n### Common Issues:\n\nOutput of the tool is ZIP archive. In order to view report on Seven Bridges platform, you can use SBG Html2b64 tool. It is advised to scatter SBG Html2b64 so it would be able to process an array of files. The example can be seen in [FastQC Analysis workflow](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/fastqc-analysis/) which you can also use instead of this tool.",
        "sbg:projectName": "Kawasaki_Japan",
        "stdin": "",
        "sbg:contributors": [
          "tsang"
        ],
        "id": "krishnanus/kawasaki-japan/fastqc-0-11-4/0",
        "sbg:revisionNotes": "Copy of admin/sbg-public-data/fastqc-0-11-4/8",
        "sbg:toolkit": "FastQC",
        "sbg:toolAuthor": "Babraham Institute",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "tsang",
            "sbg:revisionNotes": "Copy of admin/sbg-public-data/fastqc-0-11-4/8",
            "sbg:revision": 0,
            "sbg:modifiedOn": 1500830025
          }
        ],
        "sbg:modifiedOn": 1500830025
      },
      "inputs": [
        {
          "id": "#FastQC.threads"
        },
        {
          "id": "#FastQC.quiet"
        },
        {
          "id": "#FastQC.nogroup"
        },
        {
          "id": "#FastQC.nano"
        },
        {
          "id": "#FastQC.memory_per_job"
        },
        {
          "id": "#FastQC.limits_file"
        },
        {
          "id": "#FastQC.kmers"
        },
        {
          "id": "#FastQC.input_fastq",
          "source": [
            "#fastq2"
          ]
        },
        {
          "id": "#FastQC.format"
        },
        {
          "id": "#FastQC.cpus_per_job"
        },
        {
          "id": "#FastQC.contaminants_file"
        },
        {
          "id": "#FastQC.casava"
        },
        {
          "id": "#FastQC.adapters_file"
        }
      ],
      "sbg:y": 390.0260416666669,
      "id": "#FastQC",
      "outputs": [
        {
          "id": "#FastQC.report_zip"
        }
      ],
      "sbg:x": 520.0000000000003
    },
    {
      "run": {
        "temporaryFailCodes": [],
        "baseCommand": [
          "fastqc"
        ],
        "sbg:revision": 8,
        "successCodes": [],
        "sbg:job": {
          "inputs": {
            "input_fastq": [
              {
                "class": "File",
                "path": "/path/to/input_fastq-1.fastq",
                "secondaryFiles": [],
                "size": 0
              },
              {
                "class": "File",
                "path": "/path/to/input_fastq-2.fastq",
                "secondaryFiles": [],
                "size": 0
              }
            ],
            "quiet": true,
            "format": null,
            "memory_per_job": null,
            "threads": null,
            "cpus_per_job": null
          },
          "allocatedResources": {
            "mem": 1624,
            "cpu": 2
          }
        },
        "sbg:toolkitVersion": "0.11.4",
        "sbg:validationErrors": [],
        "sbg:id": "admin/sbg-public-data/fastqc-0-11-4/8",
        "sbg:categories": [
          "FASTQ-Processing",
          "Quality-Control",
          "Quantification"
        ],
        "sbg:project": "admin/sbg-public-data",
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "itemSeparator": null,
              "position": 100
            },
            "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ, BAM, SAM",
            "type": [
              {
                "name": "input_fastq",
                "items": "File",
                "type": "array"
              }
            ],
            "id": "#input_fastq",
            "label": "Input file",
            "description": "Input file.",
            "sbg:category": "File inputs"
          },
          {
            "sbg:toolDefaultValue": "7",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--kmers"
            },
            "sbg:altPrefix": "-f",
            "id": "#kmers",
            "sbg:category": "Options",
            "label": "Kmers",
            "description": "Specifies the length of Kmer to look for in the Kmer content module. Specified Kmer length must be between 2 and 10. Default length is 7 if not specified.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--limits"
            },
            "sbg:fileTypes": "TXT",
            "sbg:altPrefix": "-l",
            "id": "#limits_file",
            "sbg:category": "File inputs",
            "label": "Limits",
            "description": "Specifies a non-default file which contains a set of criteria which will be used to determine the warn/error limits for the various modules.  This file can also be used to selectively remove some modules from the output all together.  The format needs to mirror the default limits.txt file found in the Configuration folder.",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--adapters"
            },
            "sbg:fileTypes": "TXT",
            "sbg:altPrefix": "-a",
            "id": "#adapters_file",
            "sbg:category": "File inputs",
            "label": "Adapters",
            "description": "Specifies a non-default file which contains the list of adapter sequences which will be explicity searched against the library. The file must contain sets of named adapters in the form name[tab]sequence.  Lines prefixed with a hash will be ignored.",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--contaminants"
            },
            "sbg:fileTypes": "TXT",
            "sbg:altPrefix": "-c",
            "id": "#contaminants_file",
            "sbg:category": "File inputs",
            "label": "Contaminants",
            "description": "Specifies a non-default file which contains the list of contaminants to screen overrepresented sequences against. The file must contain sets of named contaminants in the form name[tab]sequence.  Lines prefixed with a hash will be ignored.",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "sbg:toolDefaultValue": "FASTQ",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--format"
            },
            "sbg:altPrefix": "-f",
            "id": "#format",
            "sbg:category": "Options",
            "label": "Format",
            "description": "Bypasses the normal sequence file format detection and forces the program to use the specified format.  Valid formats are BAM, SAM, BAM_mapped, SAM_mapped and FASTQ.",
            "type": [
              "null",
              {
                "symbols": [
                  "bam",
                  "sam",
                  "bam_mapped",
                  "sam_mapped",
                  "fastq"
                ],
                "name": "format",
                "type": "enum"
              }
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": false,
              "prefix": "--nogroup"
            },
            "type": [
              "null",
              "boolean"
            ],
            "id": "#nogroup",
            "label": "Nogroup",
            "description": "Disable grouping of bases for reads >50bp. All reports will show data for every base in the read.  WARNING: Using this option will cause fastqc to crash and burn if you use it on really long reads, and your plots may end up a ridiculous size. You have been warned.",
            "sbg:category": "Options"
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": false,
              "prefix": "--nano"
            },
            "type": [
              "null",
              "boolean"
            ],
            "id": "#nano",
            "label": "Nano",
            "description": "Files come from naopore sequences and are in fast5 format. In this mode you can pass in directories to process and the program will take in all fast5 files within those directories and produce a single output file from the sequences found in all files.",
            "sbg:category": "Options"
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": false,
              "prefix": "--casava"
            },
            "type": [
              "null",
              "boolean"
            ],
            "id": "#casava",
            "label": "Casava",
            "description": "Files come from raw casava output. Files in the same sample group (differing only by the group number) will be analysed as a set rather than individually. Sequences with the filter flag set in the header will be excluded from the analysis. Files must have the same names given to them by casava (including being gzipped and ending with .gz) otherwise they won't be grouped together correctly.",
            "sbg:category": "Options"
          },
          {
            "sbg:toolDefaultValue": "1",
            "inputBinding": {
              "valueFrom": {
                "script": "{\n//if \"threads\" is not specified\n//number of threads is determined based on number of inputs\n  if (! $job.inputs.threads){\n    $job.inputs.threads = [].concat($job.inputs.input_fastq).length\n  }\n  return Math.min($job.inputs.threads,7)\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--threads"
            },
            "sbg:altPrefix": "-t",
            "id": "#threads",
            "sbg:category": "Options",
            "label": "Threads",
            "description": "Specifies the number of files which can be processed simultaneously.  Each thread will be allocated 250MB of memory so you shouldn't run more threads than your available memory will cope with, and not more than 6 threads on a 32 bit machine.",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--quiet"
            },
            "sbg:altPrefix": "-q",
            "id": "#quiet",
            "sbg:category": "Options",
            "label": "Quiet",
            "description": "Supress all progress messages on stdout and only report errors.",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "sbg:toolDefaultValue": "Determined by the number of input files",
            "type": [
              "null",
              "int"
            ],
            "id": "#cpus_per_job",
            "label": "Number of CPUs.",
            "description": "Number of CPUs to be allocated per execution of FastQC.",
            "sbg:category": "Execution parameters"
          },
          {
            "sbg:toolDefaultValue": "Determined by the number of input files",
            "type": [
              "null",
              "int"
            ],
            "id": "#memory_per_job",
            "label": "Amount of memory allocated per job execution.",
            "description": "Amount of memory allocated per execution of FastQC job.",
            "sbg:category": "Execution parameters"
          }
        ],
        "sbg:createdBy": "mladenlSBG",
        "sbg:links": [
          {
            "id": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc/",
            "label": "Homepage"
          },
          {
            "id": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.11.4_source.zip",
            "label": "Source Code"
          },
          {
            "id": "https://wiki.hpcc.msu.edu/display/Bioinfo/FastQC+Tutorial",
            "label": "Wiki"
          },
          {
            "id": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.11.4.zip",
            "label": "Download"
          },
          {
            "id": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc",
            "label": "Publication"
          }
        ],
        "sbg:modifiedBy": "admin",
        "sbg:projectName": "SBG Public data",
        "sbg:sbgMaintained": false,
        "sbg:cmdPreview": "fastqc  --noextract --outdir .  /path/to/input_fastq-1.fastq  /path/to/input_fastq-2.fastq",
        "label": "FastQC",
        "stdout": "",
        "sbg:latestRevision": 8,
        "hints": [
          {
            "dockerPull": "images.sbgenomics.com/mladenlsbg/fastqc:0.11.4",
            "class": "DockerRequirement",
            "dockerImageId": "759c4c8fbafd"
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n  // if cpus_per_job is set, it takes precedence\n  if ($job.inputs.cpus_per_job) {\n    return $job.inputs.cpus_per_job \n  }\n  // if threads parameter is set, the number of CPUs is set based on that parametere\n  else if ($job.inputs.threads) {\n    return $job.inputs.threads\n  }\n  // else the number of CPUs is determined by the number of input files, up to 7 -- default\n  else return Math.min([].concat($job.inputs.input_fastq).length,7)\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "class": "sbg:MemRequirement",
            "value": {
              "script": "{\n  // if memory_per_job is set, it takes precedence\n  if ($job.inputs.memory_per_job){\n    return $job.inputs.memory_per_job\n  }\n  // if threads parameter is set, memory req is set based on the number of threads\n  else if ($job.inputs.threads){\n    return 1024 + 300*$job.inputs.threads\n  }\n  // else the memory req is determined by the number of input files, up to 7 -- default\n  else return (1024 + 300*Math.min([].concat($job.inputs.input_fastq).length,7))\n}\n\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "class": "ExpressionEngineRequirement"
          }
        ],
        "cwlVersion": "sbg:draft-2",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "sbg:createdOn": 1447773725,
        "description": "FastQC reads a set of sequence files and produces a quality control (QC) report from each one. These reports consist of a number of different modules, each of which will help identify a different type of potential problem in your data. \n\nSince it's necessary to convert the tool report in order to show them on Seven Bridges platform, it's recommended to use [FastQC Analysis workflow instead](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/fastqc-analysis/). \n\nFastQC is a tool which takes a FASTQ file and runs a series of tests on it to generate a comprehensive QC report.  This report will tell you if there is anything unusual about your sequence.  Each test is flagged as a pass, warning, or fail depending on how far it departs from what you would expect from a normal large dataset with no significant biases.  It is important to stress that warnings or even failures do not necessarily mean that there is a problem with your data, only that it is unusual.  It is possible that the biological nature of your sample means that you would expect this particular bias in your results.\n\n### Common Issues:\n\nOutput of the tool is ZIP archive. In order to view report on Seven Bridges platform, you can use SBG Html2b64 tool. It is advised to scatter SBG Html2b64 so it would be able to process an array of files. The example can be seen in [FastQC Analysis workflow](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/fastqc-analysis/) which you can also use instead of this tool.",
        "arguments": [
          {
            "valueFrom": "--noextract",
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": ".",
            "separate": true,
            "prefix": "--outdir"
          }
        ],
        "sbg:license": "GNU General Public License v3.0 only",
        "outputs": [
          {
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "input_fastq"
              },
              "sbg:inheritMetadataFrom": "#input_fastq",
              "glob": "*_fastqc.zip"
            },
            "type": [
              "null",
              {
                "name": "report_zip",
                "items": "File",
                "type": "array"
              }
            ],
            "id": "#report_zip",
            "label": "Report zip",
            "description": "Zip archive of the report.",
            "sbg:fileTypes": "ZIP"
          }
        ],
        "stdin": "",
        "sbg:contributors": [
          "djordje_klisic",
          "mladenlSBG",
          "admin"
        ],
        "id": "https://cgc-api.sbgenomics.com/v2/apps/admin/sbg-public-data/fastqc-0-11-4/8/raw/",
        "sbg:revisionNotes": "* Fixed the JS expression for the CPU and Memory allocation\n* Added cpus_per_job and memory_per_job parameters\n* Removed default version for format, so the tool can handle combinations of file formats",
        "sbg:toolkit": "FastQC",
        "sbg:toolAuthor": "Babraham Institute",
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "mladenlSBG",
            "sbg:revisionNotes": null,
            "sbg:revision": 0,
            "sbg:modifiedOn": 1447773725
          },
          {
            "sbg:modifiedBy": "djordje_klisic",
            "sbg:revisionNotes": null,
            "sbg:revision": 1,
            "sbg:modifiedOn": 1459957440
          },
          {
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": null,
            "sbg:revision": 2,
            "sbg:modifiedOn": 1471861482
          },
          {
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": "Input categories added.",
            "sbg:revision": 3,
            "sbg:modifiedOn": 1476440178
          },
          {
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": "FASTQ input changed from single file to array. Added better thread handling. \n\nIMPORTANT NOTICE: If updating this tool in existing workflow, it's necessary to REMOVE SCATTER (uncheck it) from input_fastq or it might break the pipeline.",
            "sbg:revision": 4,
            "sbg:modifiedOn": 1476440178
          },
          {
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": "FASTQ input changed from single file to array. Added better thread handling.\n\nIMPORTANT NOTICE: If updating this tool in existing workflow, it's necessary to REMOVE SCATTER (uncheck it) from input_fastq or it might break the pipeline.",
            "sbg:revision": 5,
            "sbg:modifiedOn": 1476440178
          },
          {
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": "IMPORTANT NOTICE: If updating this tool in existing workflow, it's necessary to REMOVE SCATTER (uncheck it) from input_fastq or it might break the pipeline.\"\n\nAdded automatised handling of BAM and SAM files. Also, added security measures for better automated threading handling.",
            "sbg:revision": 6,
            "sbg:modifiedOn": 1489067520
          },
          {
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": "Changed the file types of limits, adapters and contaminants files to be TXT, they have to be in format name[tab]sequence. Format should be similar to the one in the Configuration folder provided with FastQC, txt files.\n\n\"IMPORTANT NOTICE: If updating this tool in existing workflow, it's necessary to REMOVE SCATTER (uncheck it) from input_fastq or it might break the pipeline.\"",
            "sbg:revision": 7,
            "sbg:modifiedOn": 1489067520
          },
          {
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": "* Fixed the JS expression for the CPU and Memory allocation\n* Added cpus_per_job and memory_per_job parameters\n* Removed default version for format, so the tool can handle combinations of file formats",
            "sbg:revision": 8,
            "sbg:modifiedOn": 1493298709
          }
        ],
        "sbg:modifiedOn": 1493298709
      },
      "inputs": [
        {
          "id": "#FastQC_1.input_fastq",
          "source": [
            "#fastq1"
          ]
        },
        {
          "id": "#FastQC_1.kmers"
        },
        {
          "id": "#FastQC_1.limits_file"
        },
        {
          "id": "#FastQC_1.adapters_file"
        },
        {
          "id": "#FastQC_1.contaminants_file"
        },
        {
          "id": "#FastQC_1.format"
        },
        {
          "id": "#FastQC_1.nogroup"
        },
        {
          "id": "#FastQC_1.nano"
        },
        {
          "id": "#FastQC_1.casava"
        },
        {
          "id": "#FastQC_1.threads"
        },
        {
          "id": "#FastQC_1.quiet"
        },
        {
          "id": "#FastQC_1.cpus_per_job"
        },
        {
          "id": "#FastQC_1.memory_per_job"
        }
      ],
      "sbg:y": 540.026041666667,
      "id": "#FastQC_1",
      "outputs": [
        {
          "id": "#FastQC_1.report_zip"
        }
      ],
      "sbg:x": 523.3333333333336
    }
  ],
  "sbg:validationErrors": [],
  "sbg:id": "tsang/ncbi-hackathon/pathogen-detect-star/1",
  "sbg:project": "tsang/ncbi-hackathon",
  "outputs": [
    {
      "sbg:fileTypes": "FASTQ",
      "type": [
        "null",
        {
          "items": "File",
          "type": "array"
        }
      ],
      "id": "#unmapped_reads",
      "sbg:y": 263.33335574468055,
      "source": [
        "#STAR.unmapped_reads"
      ],
      "sbg:includeInPorts": true,
      "label": "unmapped_reads",
      "required": false,
      "sbg:x": 1590.3334698942015
    },
    {
      "sbg:fileTypes": "TAB",
      "type": [
        "null",
        "File"
      ],
      "id": "#reads_per_gene",
      "sbg:y": 450.9999885956437,
      "source": [
        "#STAR.reads_per_gene"
      ],
      "sbg:includeInPorts": true,
      "label": "reads_per_gene",
      "required": false,
      "sbg:x": 1478.3334658410854
    },
    {
      "sbg:fileTypes": "OUT",
      "type": [
        "null",
        {
          "items": "File",
          "type": "array"
        }
      ],
      "id": "#log_files",
      "sbg:y": 334.33336808946495,
      "source": [
        "#STAR.log_files"
      ],
      "sbg:includeInPorts": true,
      "label": "log_files",
      "required": false,
      "sbg:x": 1474.3333848317473
    },
    {
      "sbg:fileTypes": "SAM, BAM",
      "type": [
        "null",
        "File"
      ],
      "id": "#aligned_reads",
      "sbg:y": 206.33335844675773,
      "source": [
        "#STAR.aligned_reads"
      ],
      "sbg:includeInPorts": true,
      "label": "aligned_reads",
      "required": false,
      "sbg:x": 1469.6667178471891
    },
    {
      "sbg:fileTypes": "FA, FASTA",
      "type": [
        "null",
        "File"
      ],
      "id": "#final_contigs",
      "sbg:y": 130.00000249014957,
      "source": [
        "#megahit.final_contigs"
      ],
      "sbg:includeInPorts": true,
      "label": "final_contigs",
      "required": false,
      "sbg:x": 1588.3334341579039
    },
    {
      "sbg:fileTypes": "HMTL",
      "type": [
        "null",
        "File"
      ],
      "id": "#output",
      "sbg:y": -118.33333195580363,
      "source": [
        "#krona_blast.output"
      ],
      "sbg:includeInPorts": true,
      "label": "output",
      "required": false,
      "sbg:x": 1575.0000209675886
    },
    {
      "sbg:fileTypes": "XML",
      "type": [
        "null",
        "File"
      ],
      "id": "#output_1",
      "sbg:y": 5.000000596046451,
      "source": [
        "#blast.output"
      ],
      "sbg:includeInPorts": true,
      "label": "output_1",
      "required": false,
      "sbg:x": 1581.6666456196021
    },
    {
      "sbg:fileTypes": "ZIP",
      "type": [
        "null",
        {
          "name": "report_zip",
          "items": "File",
          "type": "array"
        }
      ],
      "id": "#report_zip",
      "sbg:y": 573.3333754009682,
      "source": [
        "#FastQC.report_zip"
      ],
      "sbg:includeInPorts": true,
      "label": "report_zip",
      "required": false,
      "sbg:x": 1486.6666436327803
    },
    {
      "type": [
        "null",
        {
          "name": "report_zip",
          "items": "File",
          "type": "array"
        }
      ],
      "id": "#report_zip_1",
      "sbg:y": 593.3332927624364,
      "source": [
        "#FastQC_1.report_zip"
      ],
      "sbg:includeInPorts": true,
      "label": "report_zip_1",
      "sbg:x": 1491.6667722596087
    }
  ],
  "inputs": [
    {
      "type": [
        "File"
      ],
      "sbg:y": 510.6667051182864,
      "id": "#genome",
      "label": "genome",
      "sbg:fileTypes": "TAR",
      "sbg:x": 77.33333894941556
    },
    {
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -116.66666707727632,
      "id": "#taxonomytab",
      "label": "taxonomytab",
      "sbg:fileTypes": "TAB",
      "sbg:x": 103.33333770434068
    },
    {
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 11.666667991214396,
      "id": "#accession2taxid",
      "label": "accession2taxid",
      "sbg:fileTypes": "sorted",
      "sbg:x": 100.00002151065479
    },
    {
      "type": [
        "File"
      ],
      "sbg:y": 135.00001655684636,
      "id": "#database_1",
      "label": "database_1",
      "sbg:fileTypes": "TAR.GZ",
      "sbg:x": 93.33329380882945
    },
    {
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 260.0000140931875,
      "id": "#fastq2",
      "label": "fastq2",
      "sbg:fileTypes": "FASTQ.GZ",
      "sbg:x": 84.99998029072994
    },
    {
      "type": [
        "File"
      ],
      "sbg:y": 383.3333288166252,
      "id": "#fastq1",
      "label": "fastq1",
      "sbg:fileTypes": "FASTQ.GZ",
      "sbg:x": 81.66664695739661
    },
    {
      "sbg:toolDefaultValue": "meta",
      "sbg:suggestedValue": "meta",
      "type": [
        "null",
        {
          "symbols": [
            "meta",
            "meta-sensitive",
            "meta-large",
            "bulk",
            "single-cell"
          ],
          "name": "preset",
          "type": "enum"
        }
      ],
      "sbg:stageInput": null,
      "id": "#preset",
      "sbg:includeInPorts": false,
      "description": "MEGAHIT --presets option provides five preset parameter combinations:  {meta} - General metagenome assembly, such as guts; {meta-sensitive} - More sensitive metagenome assembly, but slower; {meta-large} - Large and complex metagenome assembly, such as soil; {bulk} - Experimental; assembly of standard bulk sequencing with sufficient depth; {single-cell} - Experimental; single-cell sequence assembly.  To fine tune parameters for specific datasets, please find our suggestions on this wiki page.",
      "required": false
    },
    {
      "id": "#SeqType",
      "sbg:suggestedValue": "single-end",
      "type": [
        {
          "symbols": [
            "pair-end",
            "interleaved-pair-end",
            "single-end"
          ],
          "name": "SeqType",
          "type": "enum"
        }
      ],
      "description": "./megahit [options] {-1 <pe_1.fq> -2 <pe_2.fq> | --12 <pe12.fq> | -r <se.fq>} -1/-2, --12 and -r are parameters for inputting paired-end, interleaved-paired-end and single-end files. They accept files in fasta (.fasta, .fa, .fna) or fastq (.fastq, .fq) formats. They also supports gzip files (with .gz extensions) and bzip2 files (with .bz2 extensions). Please run ./megahit -h for detailed usage message."
    }
  ],
  "sbg:canvas_zoom": 0.5999999999999996,
  "sbg:modifiedBy": "tsang",
  "sbg:projectName": "NCBI-hackathon",
  "sbg:sbgMaintained": false,
  "id": "https://cgc-api.sbgenomics.com/v2/apps/tsang/ncbi-hackathon/pathogen-detect-star/1/raw/",
  "sbg:latestRevision": 1,
  "hints": [],
  "requirements": [],
  "cwlVersion": "sbg:draft-2",
  "sbg:appVersion": [
    "sbg:draft-2"
  ],
  "sbg:image_url": "https://cgc-brood.sbgenomics.com/static/tsang/ncbi-hackathon/pathogen-detect-star/1.png",
  "sbg:canvas_y": 106,
  "class": "Workflow",
  "sbg:canvas_x": 7,
  "sbg:createdOn": 1502764067,
  "description": "",
  "label": "pathogen_detect",
  "sbg:createdBy": "tsang",
  "sbg:contributors": [
    "tsang"
  ],
  "sbg:revisionsInfo": [
    {
      "sbg:modifiedBy": "tsang",
      "sbg:revisionNotes": "Copy of krishnanus/kawasaki-japan/pathogen-detect-star/7",
      "sbg:revision": 0,
      "sbg:modifiedOn": 1502764067
    },
    {
      "sbg:modifiedBy": "tsang",
      "sbg:revisionNotes": null,
      "sbg:revision": 1,
      "sbg:modifiedOn": 1502911325
    }
  ],
  "sbg:modifiedOn": 1502911325
}
